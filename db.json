{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-vno/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/hexo-theme-vno/source/images/logo2.jpg","path":"images/logo2.jpg","modified":0},{"_id":"themes/hexo-theme-vno/source/images/logo.jpg","path":"images/logo.jpg","modified":0},{"_id":"themes/hexo-theme-vno/source/images/favicon.png","path":"images/favicon.png","modified":0},{"_id":"themes/hexo-theme-vno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":0},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/hexo-theme-vno/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0},{"_id":"themes/hexo-theme-vno/source/css/vno.styl","path":"css/vno.styl","modified":0}],"Cache":[{"_id":"source/_posts/2015.03.06 - <无主题>.md","shasum":"769786e538eb1f809eb749439b526c4a195312ee","modified":1436514479000},{"_id":"source/_posts/2015.03.13 - <无主题>.md","shasum":"ebf66b09c5ba7bcc626fc651818e8c4691ea4f3b","modified":1436514479000},{"_id":"source/_posts/2015.03.20 - <无主题>.md","shasum":"62e65c3aec0986ffa923f3fd9c2854f13ce0ed80","modified":1436514479000},{"_id":"source/_posts/2015.03.27 - <无主题>.md","shasum":"11e8f4c20572a1750308867471adf9e19c86fbf1","modified":1436514479000},{"_id":"source/_posts/2015.04.03 - <无主题>.md","shasum":"9bc9d9c9661fbbb2ecdea27cbddda42c87e132c6","modified":1436514479000},{"_id":"source/_posts/2015.04.10 - <无主题>.md","shasum":"9cc2441e688eb0c93c41d1a1427fe1fa770d0087","modified":1436514479000},{"_id":"source/_posts/2015.04.17 - <无主题>.md","shasum":"db842649129bd23a76b922cb588dbe5f8c1b3b3b","modified":1436514479000},{"_id":"source/_posts/2015.04.24 - <无主题>.md","shasum":"b38c0cba53a93c323135f28e3f9fe3aec4afba36","modified":1436514479000},{"_id":"source/_posts/2015.05.08 - <无主题>.md","shasum":"77e9ac944a090f8982e1d4003a5e5b7fd17b8811","modified":1436514479000},{"_id":"source/_posts/2015.05.15 - <无主题>.md","shasum":"4d13a7b0dc02ba044ec8eeaa2d5b5bf46533017d","modified":1436514479000},{"_id":"source/_posts/2015.05.22 - <无主题>.md","shasum":"396d275853664fc3200480812ccf0805d83bd036","modified":1436514479000},{"_id":"source/_posts/2015.05.29 - 游戏开发.md","shasum":"d8541f93325f6b054d22d8c5063039acbfb8a20c","modified":1436514479000},{"_id":"source/_posts/2015.06.05 - 博客分享.md","shasum":"09a33f6ffece252304681f25986e32e1829f3a65","modified":1436514479000},{"_id":"source/_posts/2015.06.12 - 开源.md","shasum":"f24ef767ce47fec721e2a47dc2e6e3504b74ec8a","modified":1436514479000},{"_id":"source/_posts/2015.07.10 - 微信公众号开发.md","shasum":"d0824a39f25d140e18995d029f4000cff6b36c02","modified":1436537641000},{"_id":"source/_posts/2015.06.19 - 代码效率提升.md","shasum":"067b9391c7093224b5d32b73f5eb5058228e8fa9","modified":1436514479000},{"_id":"source/_posts/2015.06.26 - 线程并发和同步.md","shasum":"f9a79370dc285dbfc67fb705f3093b48c3366f1e","modified":1436514479000},{"_id":"source/_posts/2015.07.07 - 知其所以然.md","shasum":"94f89cadd12702bf70dd4ccda3262be8a528b9fd","modified":1436514479000},{"_id":"themes/hexo-theme-vno/LICENSE","shasum":"8c84b7a07cef17ed42b549a47eefd71bb97ae698","modified":1435503408000},{"_id":"themes/hexo-theme-vno/README.md","shasum":"8e2f82fb55ab34802d0b4348a729c1a641f39643","modified":1435503408000},{"_id":"themes/hexo-theme-vno/_config.yml","shasum":"ca7ca394a4d3b428ad10bffd6d5701533b3f0089","modified":1436258402000},{"_id":"themes/hexo-theme-vno/layout/_partial/comments.ejs","shasum":"fae4605bc74b0ace145e5a11fcf449ae414d720a","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/date.ejs","shasum":"7acd28543c62c6a4cdd9a3e49bd1fb77f0e9ab78","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/footer.ejs","shasum":"eecbb0993f31ae93d55355e48f211056e5abb93a","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/google_analytics.ejs","shasum":"eddc6b239bf82409856431d8f0bb5ad8d52ab464","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/head.ejs","shasum":"d41c46eaf41fad329d9ac4c36b32dfba4dfd00f6","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/side-panel.ejs","shasum":"646be378b9cba52503815da926a16747548f1436","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/social.ejs","shasum":"e804b5ae116113457eba5008e1c2ada936cfb28c","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/_partial/tags.ejs","shasum":"ffcc2844bf1fae8a766e807c316129774bd4ad43","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/layout.ejs","shasum":"b23c2e74b536dd7f9d5db826cb9ab0854ca35b06","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/page.ejs","shasum":"24ae0f52dca582d4f76524c928da59d3500b40ff","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/index.ejs","shasum":"83826a3ffe99bc46e129cb52f5c5d4f16883cbb7","modified":1435503408000},{"_id":"themes/hexo-theme-vno/layout/post.ejs","shasum":"056be8f90cca8626756fe0fd0d685dd8db27ba41","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/css/_variables.styl","shasum":"8d7e3e75cf2e2806ba2aacde9ef9c3626929e3e2","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/css/_partial/highlight.styl","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/css/_animate.styl","shasum":"a2f854fbdc52a5657dd5e2b95cc96c0da32f3ea2","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/css/vno.styl","shasum":"d0966e8165a1b0c63420cb6467ee0f3707516caa","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/images/favicon.png","shasum":"c58e6f103955d172a4b2d758c5d0db016982b17d","modified":1431913480000},{"_id":"themes/hexo-theme-vno/source/images/logo.jpg","shasum":"0d406042b24519162c4eae06207ef4618ee9c3d4","modified":1435509856000},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/images/logo2.jpg","shasum":"463b1b42133e7ef7a0d175bf762edd7bc442c1bd","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/js/main.js","shasum":"8bdf96eee9b603b2f36acf0276c05e881b8d79c7","modified":1435503408000},{"_id":"themes/hexo-theme-vno/source/images/background-cover.jpg","shasum":"8c34f80bc4cb665da90b040e32ad1eb4d249b9a0","modified":1435508398000},{"_id":"themes/hexo-theme-vno/source/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1435503408000},{"_id":"public/js/main.js","modified":1436545576512,"shasum":"8bdf96eee9b603b2f36acf0276c05e881b8d79c7"},{"_id":"public/images/logo2.jpg","modified":1436545576518,"shasum":"463b1b42133e7ef7a0d175bf762edd7bc442c1bd"},{"_id":"public/images/logo.jpg","modified":1436545576521,"shasum":"0d406042b24519162c4eae06207ef4618ee9c3d4"},{"_id":"public/images/favicon.png","modified":1436545576522,"shasum":"c58e6f103955d172a4b2d758c5d0db016982b17d"},{"_id":"public/images/background-cover.jpg","modified":1436545576525,"shasum":"8c34f80bc4cb665da90b040e32ad1eb4d249b9a0"},{"_id":"public/fonts/fontawesome-webfont.woff","modified":1436545576526,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/fonts/fontawesome-webfont.ttf","modified":1436545576529,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/fonts/fontawesome-webfont.svg","modified":1436545576532,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/fonts/fontawesome-webfont.eot","modified":1436545576534,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/fonts/FontAwesome.otf","modified":1436545576535,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/css/vno.css","modified":1436545577011,"shasum":"1b6741b2a277f6dc81f0e154f4fea0d5e4edaeb9"},{"_id":"public/2015/07/10/2015.07.10 - 微信公众号开发/index.html","modified":1436545577243,"shasum":"04153818e3247d9220dab0d308069a26806ae7cd"},{"_id":"public/2015/07/08/2015.07.07 - 知其所以然/index.html","modified":1436545577259,"shasum":"c9f8337f3cd37affbcebf6f0af9e43f0042bbc94"},{"_id":"public/2015/06/27/2015.06.26 - 线程并发和同步/index.html","modified":1436545577271,"shasum":"33cc2a1558bff635d88a4df67a01540544b50ef1"},{"_id":"public/2015/06/20/2015.06.19 - 代码效率提升/index.html","modified":1436545577280,"shasum":"b18acbd9d0c1e558d8d8a992844d402fe3512607"},{"_id":"public/2015/06/13/2015.06.12 - 开源/index.html","modified":1436545577290,"shasum":"05604f68df8b34ad030a50938170b65dbc2ab8bf"},{"_id":"public/2015/06/06/2015.06.05 - 博客分享/index.html","modified":1436545577299,"shasum":"c874b5d6de7194011da115d6775549de4889117a"},{"_id":"public/2015/05/30/2015.05.29 - 游戏开发/index.html","modified":1436545577310,"shasum":"67bb9176709d36ddb047e7b2eecf671a8cc68e8a"},{"_id":"public/2015/05/23/2015.05.22 - <无主题>/index.html","modified":1436545577324,"shasum":"bf3ada32248382b30e362158b9a58cc052a9822e"},{"_id":"public/2015/05/16/2015.05.15 - <无主题>/index.html","modified":1436545577332,"shasum":"3fe09e3085101992f270bf26f97e30b5566ec45d"},{"_id":"public/2015/05/09/2015.05.08 - <无主题>/index.html","modified":1436545577342,"shasum":"ebc38841f9fa43ec9ea7e4e9ee761c8318ad51a5"},{"_id":"public/2015/04/25/2015.04.24 - <无主题>/index.html","modified":1436545577351,"shasum":"b062577f891b13301cf6abbbda0f79c34623339b"},{"_id":"public/2015/04/18/2015.04.17 - <无主题>/index.html","modified":1436545577361,"shasum":"100da2388b256c61c829528b8a33fe9c142f8902"},{"_id":"public/2015/04/11/2015.04.10 - <无主题>/index.html","modified":1436545577370,"shasum":"94e2715b0d68af38e69c32eb0bed8379f8062eed"},{"_id":"public/2015/04/04/2015.04.03 - <无主题>/index.html","modified":1436545577393,"shasum":"1eda2834f01ed242856ad7ca7dbfec675db22623"},{"_id":"public/2015/03/28/2015.03.27 - <无主题>/index.html","modified":1436545577399,"shasum":"8ea4af4e91ff4f90381977e2207e756b22900f4f"},{"_id":"public/2015/03/21/2015.03.20 - <无主题>/index.html","modified":1436545577405,"shasum":"c606e0624ad2fb0360f5ee9f882365dfd1f9bbaf"},{"_id":"public/2015/03/14/2015.03.13 - <无主题>/index.html","modified":1436545577411,"shasum":"74c7aafe8106828289cebc8ddfeac91fa4cca3ae"},{"_id":"public/2015/03/07/2015.03.06 - <无主题>/index.html","modified":1436545577418,"shasum":"34658242f8d38d0836b59a55a8464bd65486e3b0"},{"_id":"public/archives/index.html","modified":1436545577448,"shasum":"985cffcaa59bc73006f54acad3d6210aed9fcb54"},{"_id":"public/archives/2015/index.html","modified":1436545577479,"shasum":"985cffcaa59bc73006f54acad3d6210aed9fcb54"},{"_id":"public/archives/2015/03/index.html","modified":1436545577487,"shasum":"4befb7502bcca8d17be31a772e3a7ff48b489e3d"},{"_id":"public/archives/2015/04/index.html","modified":1436545577496,"shasum":"0e3effc335570b638f76a672f72c7957a145556a"},{"_id":"public/archives/2015/05/index.html","modified":1436545577505,"shasum":"ca4be84b7767d53a48629720a914765fef6bd8ef"},{"_id":"public/archives/2015/06/index.html","modified":1436545577515,"shasum":"57ab0fdb89e8ce84c752f3e85b6a19fe8e6ecbef"},{"_id":"public/archives/2015/07/index.html","modified":1436545577522,"shasum":"9a5e8f5d3d90beabbbb53c687406f0e97f1b8a7a"},{"_id":"public/index.html","modified":1436545577553,"shasum":"7a597026ff1fefcc1e31ca580fd6b9c916ed0172"},{"_id":"public/tags/线程/index.html","modified":1436545577559,"shasum":"e11e2acb20ee19666699fe642c7be94083834825"},{"_id":"public/tags/同步异步/index.html","modified":1436545577566,"shasum":"e11e2acb20ee19666699fe642c7be94083834825"},{"_id":"public/tags/开发效率/index.html","modified":1436545577571,"shasum":"4bb0875d1829f2527e615f41a91c72364ac6782f"},{"_id":"public/tags/效率/index.html","modified":1436545577577,"shasum":"4bb0875d1829f2527e615f41a91c72364ac6782f"},{"_id":"public/tags/博客/index.html","modified":1436545577583,"shasum":"078e3e8ef4e21d2c1b12587fefaa02e42bfdd249"},{"_id":"public/tags/网站/index.html","modified":1436545577589,"shasum":"078e3e8ef4e21d2c1b12587fefaa02e42bfdd249"},{"_id":"public/tags/游戏/index.html","modified":1436545577595,"shasum":"7635188eb50716d815c1a2aad9c5549eb728b07a"}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"《无主题》","date":"2015-03-06T23:04:29.000Z","_content":"\n#### iOS开发 - label自适应高度和宽度 - 张超耀\n- 调用 `-(CGSize)sizeWithFont:(UIFont *)font` 方法\n- 根据CGSize来决定label的width和height\n\n\n#### iOS开发 - label显示不同的字体和颜色 - 张超耀\n- 调用 -(void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range;\n- 参数解释：name来决定是改变字体的大小还是字体的颜色；range来判断需要改变的位置。\n\n\n#### OpenGL ES介绍 - 朱崇铭\n- OpenGL ES 是专门为手持设备制定的 3D 规范，它是 OpenGL 的简化版。主要是应对嵌入式环境和应用的要求。在高效完成2D/3D界面的同时，达到了降低功耗的效果。\n- OpenGL ES的运行环境是在GLKit 中提供方便使用 OpenGL ES 的辅助 GLKView。\n- 在用OpenGL ES 绘制层级的时候，为了让 UIView 显示OpenGL内容，我们必须将默认的 layer 类型修改为 CAEAGLLayer 类型。\n- OpenGL ES的基本绘图功能：(http://bbs.tairan.com/article-5-1.html)\n- layer的配置完成，创建与设置与 OpenGL ES 相关的东西。事例代码如下：\n- EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2;\n    _context = [[EAGLContext alloc] initWithAPI:api];\n    if (!_context) {\n        NSLog(@\"Failed to initialize OpenGLES 2.0 context\");\n        exit(1);\n    }\n    // 设置为当前上下文\n    if (![EAGLContext setCurrentContext:_context]) {\n        NSLog(@\"Failed to set current OpenGL context\");\n        exit(1);\n\n#### git&git-flow 基本操作 - 曾铭\n- [git](http://git-scm.com/) 是类似 svn 的版本控制系统，[git-flow](http://nvie.com/posts/a-successful-git-branching-model/) 是推荐的 git 工作流； \n- git 和 svn 的区别：分布 vs 集中，多分支 vs 不用分支，小步提交 vs 大块提交；\n- 用 SourceTree 演示建立 git local repository，stag，commit，用 git-flow 建立 branch，合并等操作\n- 介绍 git remote repository 概念，介绍 pull，push，fetch 等操作\n- [git 教程](tutorial-git)","source":"_posts/2015.03.06 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-03-06 23:04:29\ntags:\n---\n\n#### iOS开发 - label自适应高度和宽度 - 张超耀\n- 调用 `-(CGSize)sizeWithFont:(UIFont *)font` 方法\n- 根据CGSize来决定label的width和height\n\n\n#### iOS开发 - label显示不同的字体和颜色 - 张超耀\n- 调用 -(void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range;\n- 参数解释：name来决定是改变字体的大小还是字体的颜色；range来判断需要改变的位置。\n\n\n#### OpenGL ES介绍 - 朱崇铭\n- OpenGL ES 是专门为手持设备制定的 3D 规范，它是 OpenGL 的简化版。主要是应对嵌入式环境和应用的要求。在高效完成2D/3D界面的同时，达到了降低功耗的效果。\n- OpenGL ES的运行环境是在GLKit 中提供方便使用 OpenGL ES 的辅助 GLKView。\n- 在用OpenGL ES 绘制层级的时候，为了让 UIView 显示OpenGL内容，我们必须将默认的 layer 类型修改为 CAEAGLLayer 类型。\n- OpenGL ES的基本绘图功能：(http://bbs.tairan.com/article-5-1.html)\n- layer的配置完成，创建与设置与 OpenGL ES 相关的东西。事例代码如下：\n- EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2;\n    _context = [[EAGLContext alloc] initWithAPI:api];\n    if (!_context) {\n        NSLog(@\"Failed to initialize OpenGLES 2.0 context\");\n        exit(1);\n    }\n    // 设置为当前上下文\n    if (![EAGLContext setCurrentContext:_context]) {\n        NSLog(@\"Failed to set current OpenGL context\");\n        exit(1);\n\n#### git&git-flow 基本操作 - 曾铭\n- [git](http://git-scm.com/) 是类似 svn 的版本控制系统，[git-flow](http://nvie.com/posts/a-successful-git-branching-model/) 是推荐的 git 工作流； \n- git 和 svn 的区别：分布 vs 集中，多分支 vs 不用分支，小步提交 vs 大块提交；\n- 用 SourceTree 演示建立 git local repository，stag，commit，用 git-flow 建立 branch，合并等操作\n- 介绍 git remote repository 概念，介绍 pull，push，fetch 等操作\n- [git 教程](tutorial-git)","slug":"2015.03.06 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dx80000tfptkyiyb9lc"},{"title":"微信公众号开发","date":"2015-07-10T15:51:00.000Z","_content":"\n## 对于微信公众号开发的疑问\n\n- 微信公众点与自己服务器配对流程\n- 本地如何调试\n- 微信整体流程中用到的一些特殊协议?\n- openId/unionId 哪里查看\n- access_token 为什么要有时间限制 为什么是2小时\n- 网页授权如何做的?能取到哪些信息?\n- 参加活动不关注 能拿到多少信息\n- 菜单type类型\n- 有哪些好的第三方开发工具包\n- 所有的活动行为全部调一个url 有没有好的分发解决方案\n\n\n## 公众号查询通讯录的实现 - 曾铭\n\n### 思路\n- 通讯录表 -> 后台数据库\n- 用户关注公众号\n- 用户发消息（姓名）给公众号\n- 微信后台转发此消息给网站后台 post XML\n- 后台根据此消息（姓名）查询数据库，得到此人具体数据，组合 XML 返回给微信后台\n- 微信后台把具体数据展示给用户\n\n### 实现\n- 通讯录表 xls -> csv -> 导入到 LeanCloud 数据库\n- 基于 express (node.js web 框架)，建立 51offer_wechat.avosapps.com/contact_bot 站点；\n- 微信公众号后台配置开发者后台 URL，处理后台网址 get 请求，完成微信对开发者后台的验证\n- 处理网址 post 请求，完成接受消息，查询数据库，返回用户信息工作。具体参考：[这里](https://github.com/51offer/wechat_bot/commit/25d457c7430d88167d62b053a5d072d588c9c95b)\n\n### 总结\n- node.js (express) 处理网络请求的确精简方便\n- 微信公众号的所有信息都转发到一个接口，后续处理类型多时要设计合理的分发机制\n- 微信接口为什么用 XML 而不是 json 啊，这点不熟悉占用不少时间\n- 做这个很有意思，推荐大家多玩玩~\n\n## 商户端APP集成微信扫描支付 - 王胜\n\n### 准备工作\n\n* APP端微信支付SDK\n  [[Android]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317784&token=&lang=zh_CN) | [[iOS]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317782&token=&lang=zh_CN)\n* 服务端微信支付SDK\n  [[JAVA]](https://pay.weixin.qq.com/wiki/doc/api/download/wxpay_scanpay_java_sdk_proj-master.zip) |\n  [[PHP]](https://pay.weixin.qq.com/wiki/doc/api/download/WxpayAPI_php_v3.zip)\n* 服务端暴露notify接口\n* push通道\n\n### 支付流程\n\n1. 用户在APP端浏览商品\n2. 加入购物车\n3. 结算\n4. 调用提交订单接口\n5. 提交订单接口返回预支付链接(**预支付链接可根据服务端微信支付sdk生成**)\n6. APP根据链接生成二维码\n7. 用户拿起手机扫描支付\n8. 微信调用第三方开发者服务端暴露的notify接口\n9. 第三方服务端在收到notify接口调用时，更新订单库里订单状态，同时调用push通道告诉APP支付成功\n10. APP收到push命令后进行页面跳转\n \n\n\n## 微信分享 - 吴明\n- 微信工作原理\n  - ![Alt text](http://img.blog.csdn.net/20140823103621745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29vZFNob3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n- 接口：\n    - 你需要触发什么事件\n    - 微信事件触发会回调哪里接口\n- 微信服务：\n  - 订阅号：\n  - [服务号](https://mp.weixin.qq.com)\n     - [微信公众测试账号](http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n     - [微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)\n  - 企业号\n     - [微信企业号](https://qy.weixin.qq.com)\n     - [微信企业号申请体验号](https://qy.weixin.qq.com/try)\n     - [iwork365企业号体验](http://www.iwork365.com/experience)\n  - 微购物\n - 微信公众号自定义菜单开发\n      - 接口文档\n            - [获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n            - [自定义菜单创建接口](http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html)\n            - 以下操作都是在[微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)调试方法\n      - 步骤1：调用“获取access token”接口,传入你申请的测试微信公众号的appid和secret获取access_token\n      - 步骤2：调用“自定义菜单创建接口”，传入上面生成的access_token和“自定义菜单json数据\"如下\n  \n```\n{\n    \"button\": [\n        {\n            \"type\": \"view\", \n            \"name\": \"51offer\", \n            \"url\": \"http://www.51offer.com/\"\n        }, \n        {\n            \"name\": \"移动\", \n            \"sub_button\": [\n                {\n                    \"type\": \"view\", \n                    \"name\": \"blog\", \n                    \"url\": \"http://51offer.github.io/\"\n                }, \n                {\n                    \"type\": \"view\", \n                    \"name\": \"github\", \n                    \"url\": \"https://github.com/51offer/public-docs/wiki\"\n                }\n            ]\n        }, \n        {\n            \"type\": \"click\", \n            \"name\": \"我\", \n            \"key\": \"me\"\n        }\n    ]\n}\n```\n\n- 推荐：公众号：招商信用卡\n","source":"_posts/2015.07.10 - 微信公众号开发.md","raw":"title: 微信公众号开发\ndate: 2015-07-10 15:51\ntags:\n---\n\n## 对于微信公众号开发的疑问\n\n- 微信公众点与自己服务器配对流程\n- 本地如何调试\n- 微信整体流程中用到的一些特殊协议?\n- openId/unionId 哪里查看\n- access_token 为什么要有时间限制 为什么是2小时\n- 网页授权如何做的?能取到哪些信息?\n- 参加活动不关注 能拿到多少信息\n- 菜单type类型\n- 有哪些好的第三方开发工具包\n- 所有的活动行为全部调一个url 有没有好的分发解决方案\n\n\n## 公众号查询通讯录的实现 - 曾铭\n\n### 思路\n- 通讯录表 -> 后台数据库\n- 用户关注公众号\n- 用户发消息（姓名）给公众号\n- 微信后台转发此消息给网站后台 post XML\n- 后台根据此消息（姓名）查询数据库，得到此人具体数据，组合 XML 返回给微信后台\n- 微信后台把具体数据展示给用户\n\n### 实现\n- 通讯录表 xls -> csv -> 导入到 LeanCloud 数据库\n- 基于 express (node.js web 框架)，建立 51offer_wechat.avosapps.com/contact_bot 站点；\n- 微信公众号后台配置开发者后台 URL，处理后台网址 get 请求，完成微信对开发者后台的验证\n- 处理网址 post 请求，完成接受消息，查询数据库，返回用户信息工作。具体参考：[这里](https://github.com/51offer/wechat_bot/commit/25d457c7430d88167d62b053a5d072d588c9c95b)\n\n### 总结\n- node.js (express) 处理网络请求的确精简方便\n- 微信公众号的所有信息都转发到一个接口，后续处理类型多时要设计合理的分发机制\n- 微信接口为什么用 XML 而不是 json 啊，这点不熟悉占用不少时间\n- 做这个很有意思，推荐大家多玩玩~\n\n## 商户端APP集成微信扫描支付 - 王胜\n\n### 准备工作\n\n* APP端微信支付SDK\n  [[Android]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317784&token=&lang=zh_CN) | [[iOS]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317782&token=&lang=zh_CN)\n* 服务端微信支付SDK\n  [[JAVA]](https://pay.weixin.qq.com/wiki/doc/api/download/wxpay_scanpay_java_sdk_proj-master.zip) |\n  [[PHP]](https://pay.weixin.qq.com/wiki/doc/api/download/WxpayAPI_php_v3.zip)\n* 服务端暴露notify接口\n* push通道\n\n### 支付流程\n\n1. 用户在APP端浏览商品\n2. 加入购物车\n3. 结算\n4. 调用提交订单接口\n5. 提交订单接口返回预支付链接(**预支付链接可根据服务端微信支付sdk生成**)\n6. APP根据链接生成二维码\n7. 用户拿起手机扫描支付\n8. 微信调用第三方开发者服务端暴露的notify接口\n9. 第三方服务端在收到notify接口调用时，更新订单库里订单状态，同时调用push通道告诉APP支付成功\n10. APP收到push命令后进行页面跳转\n \n\n\n## 微信分享 - 吴明\n- 微信工作原理\n  - ![Alt text](http://img.blog.csdn.net/20140823103621745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29vZFNob3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n- 接口：\n    - 你需要触发什么事件\n    - 微信事件触发会回调哪里接口\n- 微信服务：\n  - 订阅号：\n  - [服务号](https://mp.weixin.qq.com)\n     - [微信公众测试账号](http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n     - [微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)\n  - 企业号\n     - [微信企业号](https://qy.weixin.qq.com)\n     - [微信企业号申请体验号](https://qy.weixin.qq.com/try)\n     - [iwork365企业号体验](http://www.iwork365.com/experience)\n  - 微购物\n - 微信公众号自定义菜单开发\n      - 接口文档\n            - [获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n            - [自定义菜单创建接口](http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html)\n            - 以下操作都是在[微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)调试方法\n      - 步骤1：调用“获取access token”接口,传入你申请的测试微信公众号的appid和secret获取access_token\n      - 步骤2：调用“自定义菜单创建接口”，传入上面生成的access_token和“自定义菜单json数据\"如下\n  \n```\n{\n    \"button\": [\n        {\n            \"type\": \"view\", \n            \"name\": \"51offer\", \n            \"url\": \"http://www.51offer.com/\"\n        }, \n        {\n            \"name\": \"移动\", \n            \"sub_button\": [\n                {\n                    \"type\": \"view\", \n                    \"name\": \"blog\", \n                    \"url\": \"http://51offer.github.io/\"\n                }, \n                {\n                    \"type\": \"view\", \n                    \"name\": \"github\", \n                    \"url\": \"https://github.com/51offer/public-docs/wiki\"\n                }\n            ]\n        }, \n        {\n            \"type\": \"click\", \n            \"name\": \"我\", \n            \"key\": \"me\"\n        }\n    ]\n}\n```\n\n- 推荐：公众号：招商信用卡\n","slug":"2015.07.10 - 微信公众号开发","published":1,"updated":"2015-07-10T14:14:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dxo0001tfptk6p80zgw"},{"title":"知其所以然","date":"2015-07-07T23:04:29.000Z","_content":"\n## 2015.07.07 - 知其所以然(10分钟解释一个和开发相关的原理)\n\n### WEB 登录『原理』 - 曾铭\n\n\n#### Session & cookie\n\n- HTTP 是无状态协议\n- Session 服务器端简单存储\n- cookie 客户端简单存储（注意：在请求头中）\n\n#### 密码如何存储\n\n- 明文存储\n- md5 碰撞库破解  md5(pwd)\n- md5+salt   md5(pwd+salt)  salt  pwd\n- sha1……都能用，千万不要自己实现散列算法\n\n#### 一个登录的过程\n\n- 明文密码\n- session_id, access_token, token\n- 第三方登录：OAuth2, OpenID\n\n----\n\n###iBeacon - 潘君\n\n- BLE\n    - RSSI(Received Signal Strength Indicator)\n    - 唯一标识码\n    - 例:[ 防丢器](http://detail.tmall.com/item.htm?spm=a1z10.1-b.w4004-3501608320.8.8JO7JE&id=22152768901)\n\n- [应用场景](http://www.brtbeacon.com/home/industry_solution.shtml)\n    - 配合微信摇一摇\n    - 商城导购\n    - 地下停车库导航\n\n- [室内定位](https://github.com/ibip/ibip_document/wiki/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84)\n    - 标签定位\n    - 三角定位\n    - 指纹定位\n\n----\n###  andoid虚拟机 - 吴明\n- 系统框架对比android vs ios\n- [ios系统框架](http://blog.csdn.net/xyz_lmn/article/details/8907502)\n-  [android系统框架](http://www.cnblogs.com/royenhome/archive/2010/04/24/1719293.html)\n-  Dalvik虚拟机\n\t- Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。它的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。\n\n- Android系统是以Linux系统为底层构建的，Android系统是开源(源代码公开)的，Android系统势必会适配到不同硬件配置的设备上，因此谷歌为了降低应用的开发难度在Linux底层之上构筑了一个名为“Dalvik”的虚拟机。\n- 一个应用，一个虚拟机实例，一个进程！！！\n- [android虚拟机详细](http://blog.csdn.net/andyxm/article/details/6126907/)\n\n- 其他：\n\t- ART模式:Android4.4中新加入的ART模式，该模式的完整名称是Androidruntime.\n\t- ART：Android 4.4开始推出的新的运行环境，在APP安装的时候使用dex2oat工具直接把DEX文件转换为机器码文件，运行的时候以机器码方式运行，可以充分利用系统性能；此外，改进的内存回收机制使得ART运行模式下的内存回收速度只有Dalvik运行时模式下的50%，也能够提升系统运行速度。\n\n----\n\n### Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏\n\nAndroid中，我们在线程之间通信传递通常采用Android的消息机制，而这机制传递的正是Message。\n\n通常，我们使用[Message.obtain()](http://developer.android.com/reference/android/os/Message.html#obtain())和[Handler.obtainMessage()](http://developer.android.com/reference/android/os/Handler.html#obtainMessage())从Message Pool中获取Message，避免直接构造Message。\n\n#### Message.obtain()源码\n\n```\n    /**\n     * Return a new Message instance from the global pool. Allows us to\n     * avoid allocating new objects in many cases.\n     */\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n\n```\n从代码片中，可以看到Message是直接由sPool赋值的。\n\n#### Handler.obtain()源码\n\n```\n    /**\n     * Returns a new {@link android.os.Message Message} from the global message pool. More efficient than\n     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).\n     *  If you don't want that facility, just call Message.obtain() instead.\n     */\n    public final Message obtainMessage()\n    {\n        return Message.obtain(this);\n    }\n\n```\nHandler.obtain()最终还是调用Message.obtain()来获取的。\n\n#### Message Pool相关源码分析\n\n##### Message Pool数据结构\n\n```\n    // sometimes we store linked lists of these things\n    /*package*/ Message next;\n    \n    private static final Object sPoolSync = new Object();\n    private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;\n\n    private static boolean gCheckRecycle = true;\n```\n从代码中可以很明确的看到，Message Pool的数据结构实际就是一个链表。sPool就是一个全局的消息池，sPoolSize记录链表长度，MAX_POOL_SIZE表示链表的最大长度为50。\n\n##### Message Pool如何存放Message\n\n```\n    /** @hide */\n    public static void updateCheckRecycle(int targetSdkVersion) {\n        if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {\n            gCheckRecycle = false;\n        }\n    }\n\n    /**\n     * Return a Message instance to the global pool.\n     * <p>\n     * You MUST NOT touch the Message after calling this function because it has\n     * effectively been freed.  It is an error to recycle a message that is currently\n     * enqueued or that is in the process of being delivered to a Handler.\n     * </p>\n     */\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n```\n从代码分析上看，消息池存放的核心方法就是上面的recycleUnchecked()方法：\n\n> 1、将待回收的Message对象字段置空（避免因Message过大，使静态的消息池内存泄漏）。\n>\n> 2、以内置锁对方式（线程安全），判断当前线程池的大小是否小于50。若小于50，直接将mesaage插入到消息池链表尾部；若大于等于50，则直接丢弃掉，交由GC管理。\n\n\n---\n\n### [消费者心理学：三个趣味经济学原理](http://i.wshang.com/Post/Default/Index/pid/32949.html) -- 张超耀\n- 价格越低为什么不但不好卖，反而价格越高越好卖\n- 为什么大手大脚的浪费反而可以拯救经济？\n- 为什么免费未必就是最好的\n\n这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。\n \n#### 价格越高越好卖——虚荣效应\n \n- 富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。\n \n- 虚荣效应主要有以下两种表现。\n \n\t- 高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。\n \n\t- 不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。\n \n#### 大手大脚的浪费能拯救经济——节约悖论\n \n- 我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。\n \n- 这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢？如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗？答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。\n \n- 一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈发不景气的恶性循环中。\n \n#### 免费未必就好——免费经济学\n \n- “世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。\n \n- 有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思；或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像“免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。\n \n- 看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。\n \n- 免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。”\n\n\n----\n###Icon制作 - 杨志平\n\n<img width=\"487\" alt=\"qq20150707-6 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542711/2952b918-24ca-11e5-8dda-f42e42f57e72.png\">\n<img width=\"568\" alt=\"qq20150707-11 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542720/2987624e-24ca-11e5-8380-658f9fc08f24.png\">\n\n####51offer的Icon的流程\n<img width=\"491\" alt=\"qq20150707-1 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542715/29552c5c-24ca-11e5-9849-bd352ede57f4.png\">\n<img width=\"497\" alt=\"qq20150707-2 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542712/2952ba3a-24ca-11e5-85b7-0149e855e0cd.png\">\n<img width=\"493\" alt=\"qq20150707-3 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542713/2952e118-24ca-11e5-9128-f30ac093e8f4.png\">\n<img width=\"493\" alt=\"qq20150707-4 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542716/29557bf8-24ca-11e5-8869-afc7972ac5bf.png\">\n<img width=\"492\" alt=\"qq20150707-5 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542714/2952e884-24ca-11e5-8ade-4f3a69c19df4.png\">\n\n\n####另一个Icon的制作的流程\n\n<img width=\"589\" alt=\"qq20150707-7 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542721/29879a5c-24ca-11e5-85a0-535bf058fa62.png\">\n<img width=\"573\" alt=\"qq20150707-8 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542718/29855f58-24ca-11e5-83b2-e5d4e679f543.png\">\n<img width=\"586\" alt=\"qq20150707-9 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542717/29851a3e-24ca-11e5-8eab-3d5703d032ea.png\">\n<img width=\"578\" alt=\"qq20150707-10 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542719/2986620e-24ca-11e5-9686-6fad2780ab63.png\">\n\n\n### Android 动画制作 - 王胜\n\n#### View Animation\n- AlphaAnimation 淡入淡出效果\n- TranslateAnimation 移动效果\n- ScaleAnimation 缩放效果\n- RotateAnimation 旋转效果\n\n原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Property Animation\nView Animation动画比较简单，一般都是单个因素的变化，如果牵扯到复杂的动画，就显得力不从心。因此，Android 3.0 引入了属性动画。注：可通过[[NineOldAndroids]](http://nineoldandroids.com/)项目在3.0之前的系统中使用Property Animation\n\n原理：暴露出差值算法的回调方法，有工程师自己发挥想象，造出奇妙的动画效果。\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Drawable Animation\n##### 逐帧动画\n原理：提供动画每个帧上的图片资源，顺序播放\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n##### ClipDrawable 剪切动画\n原理：提供一个背景图片，前景图片是一个ClipDrawable对象。通过线程操作ClipDrawable的剪切进度。\n\n实例：\n\n- ClipDrawable 定义xml文件\n \n~~~XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:clipOrientation=\"vertical\"\n    android:drawable=\"@drawable/loading_progress\"\n    android:gravity=\"bottom\">\n</clip>\n~~~\n\n- 组件引用\n\n~~~ XML\n<ImageView\n        android:id=\"@+id/iv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:scaleType=\"centerInside\"\n        android:paddingTop=\"5dp\"\n        android:paddingLeft=\"5dp\"\n        android:background=\"@drawable/loading_bg\"\n        android:src=\"@drawable/clip_loading\"/>\n~~~\n\n- 线程动态改变剪切进度\n\n``` Java\nprivate Handler handler = new Handler() {\n\t@Override\n    public void handleMessage(Message msg) {\n\t    // 如果消息是本程序发送的\n        if (msg.what == MSG_WHAT) {\n            mClipDrawable.setLevel(mProgress);\n        }\n    }\n};\n.......\nRunnable mRunnable = new Runnable() {\n\t@Override\n    public void run() {\n        isRunning = true;\n        while (isRunning) {\n            handler.sendEmptyMessage(MSG_WHAT);\n            if (mProgress > MAX_PROGRESS) {\n                mProgress = 0;\n            }\n            mProgress += 100;\n            try {\n                Thread.sleep(18);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n};\n```\n","source":"_posts/2015.07.07 - 知其所以然.md","raw":"title: 知其所以然\ndate: 2015-07-07 23:04:29\ntags:\n---\n\n## 2015.07.07 - 知其所以然(10分钟解释一个和开发相关的原理)\n\n### WEB 登录『原理』 - 曾铭\n\n\n#### Session & cookie\n\n- HTTP 是无状态协议\n- Session 服务器端简单存储\n- cookie 客户端简单存储（注意：在请求头中）\n\n#### 密码如何存储\n\n- 明文存储\n- md5 碰撞库破解  md5(pwd)\n- md5+salt   md5(pwd+salt)  salt  pwd\n- sha1……都能用，千万不要自己实现散列算法\n\n#### 一个登录的过程\n\n- 明文密码\n- session_id, access_token, token\n- 第三方登录：OAuth2, OpenID\n\n----\n\n###iBeacon - 潘君\n\n- BLE\n    - RSSI(Received Signal Strength Indicator)\n    - 唯一标识码\n    - 例:[ 防丢器](http://detail.tmall.com/item.htm?spm=a1z10.1-b.w4004-3501608320.8.8JO7JE&id=22152768901)\n\n- [应用场景](http://www.brtbeacon.com/home/industry_solution.shtml)\n    - 配合微信摇一摇\n    - 商城导购\n    - 地下停车库导航\n\n- [室内定位](https://github.com/ibip/ibip_document/wiki/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84)\n    - 标签定位\n    - 三角定位\n    - 指纹定位\n\n----\n###  andoid虚拟机 - 吴明\n- 系统框架对比android vs ios\n- [ios系统框架](http://blog.csdn.net/xyz_lmn/article/details/8907502)\n-  [android系统框架](http://www.cnblogs.com/royenhome/archive/2010/04/24/1719293.html)\n-  Dalvik虚拟机\n\t- Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。它的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。\n\n- Android系统是以Linux系统为底层构建的，Android系统是开源(源代码公开)的，Android系统势必会适配到不同硬件配置的设备上，因此谷歌为了降低应用的开发难度在Linux底层之上构筑了一个名为“Dalvik”的虚拟机。\n- 一个应用，一个虚拟机实例，一个进程！！！\n- [android虚拟机详细](http://blog.csdn.net/andyxm/article/details/6126907/)\n\n- 其他：\n\t- ART模式:Android4.4中新加入的ART模式，该模式的完整名称是Androidruntime.\n\t- ART：Android 4.4开始推出的新的运行环境，在APP安装的时候使用dex2oat工具直接把DEX文件转换为机器码文件，运行的时候以机器码方式运行，可以充分利用系统性能；此外，改进的内存回收机制使得ART运行模式下的内存回收速度只有Dalvik运行时模式下的50%，也能够提升系统运行速度。\n\n----\n\n### Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏\n\nAndroid中，我们在线程之间通信传递通常采用Android的消息机制，而这机制传递的正是Message。\n\n通常，我们使用[Message.obtain()](http://developer.android.com/reference/android/os/Message.html#obtain())和[Handler.obtainMessage()](http://developer.android.com/reference/android/os/Handler.html#obtainMessage())从Message Pool中获取Message，避免直接构造Message。\n\n#### Message.obtain()源码\n\n```\n    /**\n     * Return a new Message instance from the global pool. Allows us to\n     * avoid allocating new objects in many cases.\n     */\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n\n```\n从代码片中，可以看到Message是直接由sPool赋值的。\n\n#### Handler.obtain()源码\n\n```\n    /**\n     * Returns a new {@link android.os.Message Message} from the global message pool. More efficient than\n     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).\n     *  If you don't want that facility, just call Message.obtain() instead.\n     */\n    public final Message obtainMessage()\n    {\n        return Message.obtain(this);\n    }\n\n```\nHandler.obtain()最终还是调用Message.obtain()来获取的。\n\n#### Message Pool相关源码分析\n\n##### Message Pool数据结构\n\n```\n    // sometimes we store linked lists of these things\n    /*package*/ Message next;\n    \n    private static final Object sPoolSync = new Object();\n    private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;\n\n    private static boolean gCheckRecycle = true;\n```\n从代码中可以很明确的看到，Message Pool的数据结构实际就是一个链表。sPool就是一个全局的消息池，sPoolSize记录链表长度，MAX_POOL_SIZE表示链表的最大长度为50。\n\n##### Message Pool如何存放Message\n\n```\n    /** @hide */\n    public static void updateCheckRecycle(int targetSdkVersion) {\n        if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {\n            gCheckRecycle = false;\n        }\n    }\n\n    /**\n     * Return a Message instance to the global pool.\n     * <p>\n     * You MUST NOT touch the Message after calling this function because it has\n     * effectively been freed.  It is an error to recycle a message that is currently\n     * enqueued or that is in the process of being delivered to a Handler.\n     * </p>\n     */\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n```\n从代码分析上看，消息池存放的核心方法就是上面的recycleUnchecked()方法：\n\n> 1、将待回收的Message对象字段置空（避免因Message过大，使静态的消息池内存泄漏）。\n>\n> 2、以内置锁对方式（线程安全），判断当前线程池的大小是否小于50。若小于50，直接将mesaage插入到消息池链表尾部；若大于等于50，则直接丢弃掉，交由GC管理。\n\n\n---\n\n### [消费者心理学：三个趣味经济学原理](http://i.wshang.com/Post/Default/Index/pid/32949.html) -- 张超耀\n- 价格越低为什么不但不好卖，反而价格越高越好卖\n- 为什么大手大脚的浪费反而可以拯救经济？\n- 为什么免费未必就是最好的\n\n这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。\n \n#### 价格越高越好卖——虚荣效应\n \n- 富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。\n \n- 虚荣效应主要有以下两种表现。\n \n\t- 高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。\n \n\t- 不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。\n \n#### 大手大脚的浪费能拯救经济——节约悖论\n \n- 我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。\n \n- 这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢？如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗？答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。\n \n- 一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈发不景气的恶性循环中。\n \n#### 免费未必就好——免费经济学\n \n- “世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。\n \n- 有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思；或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像“免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。\n \n- 看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。\n \n- 免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。”\n\n\n----\n###Icon制作 - 杨志平\n\n<img width=\"487\" alt=\"qq20150707-6 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542711/2952b918-24ca-11e5-8dda-f42e42f57e72.png\">\n<img width=\"568\" alt=\"qq20150707-11 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542720/2987624e-24ca-11e5-8380-658f9fc08f24.png\">\n\n####51offer的Icon的流程\n<img width=\"491\" alt=\"qq20150707-1 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542715/29552c5c-24ca-11e5-9849-bd352ede57f4.png\">\n<img width=\"497\" alt=\"qq20150707-2 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542712/2952ba3a-24ca-11e5-85b7-0149e855e0cd.png\">\n<img width=\"493\" alt=\"qq20150707-3 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542713/2952e118-24ca-11e5-9128-f30ac093e8f4.png\">\n<img width=\"493\" alt=\"qq20150707-4 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542716/29557bf8-24ca-11e5-8869-afc7972ac5bf.png\">\n<img width=\"492\" alt=\"qq20150707-5 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542714/2952e884-24ca-11e5-8ade-4f3a69c19df4.png\">\n\n\n####另一个Icon的制作的流程\n\n<img width=\"589\" alt=\"qq20150707-7 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542721/29879a5c-24ca-11e5-85a0-535bf058fa62.png\">\n<img width=\"573\" alt=\"qq20150707-8 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542718/29855f58-24ca-11e5-83b2-e5d4e679f543.png\">\n<img width=\"586\" alt=\"qq20150707-9 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542717/29851a3e-24ca-11e5-8eab-3d5703d032ea.png\">\n<img width=\"578\" alt=\"qq20150707-10 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542719/2986620e-24ca-11e5-9686-6fad2780ab63.png\">\n\n\n### Android 动画制作 - 王胜\n\n#### View Animation\n- AlphaAnimation 淡入淡出效果\n- TranslateAnimation 移动效果\n- ScaleAnimation 缩放效果\n- RotateAnimation 旋转效果\n\n原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Property Animation\nView Animation动画比较简单，一般都是单个因素的变化，如果牵扯到复杂的动画，就显得力不从心。因此，Android 3.0 引入了属性动画。注：可通过[[NineOldAndroids]](http://nineoldandroids.com/)项目在3.0之前的系统中使用Property Animation\n\n原理：暴露出差值算法的回调方法，有工程师自己发挥想象，造出奇妙的动画效果。\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Drawable Animation\n##### 逐帧动画\n原理：提供动画每个帧上的图片资源，顺序播放\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n##### ClipDrawable 剪切动画\n原理：提供一个背景图片，前景图片是一个ClipDrawable对象。通过线程操作ClipDrawable的剪切进度。\n\n实例：\n\n- ClipDrawable 定义xml文件\n \n~~~XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:clipOrientation=\"vertical\"\n    android:drawable=\"@drawable/loading_progress\"\n    android:gravity=\"bottom\">\n</clip>\n~~~\n\n- 组件引用\n\n~~~ XML\n<ImageView\n        android:id=\"@+id/iv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:scaleType=\"centerInside\"\n        android:paddingTop=\"5dp\"\n        android:paddingLeft=\"5dp\"\n        android:background=\"@drawable/loading_bg\"\n        android:src=\"@drawable/clip_loading\"/>\n~~~\n\n- 线程动态改变剪切进度\n\n``` Java\nprivate Handler handler = new Handler() {\n\t@Override\n    public void handleMessage(Message msg) {\n\t    // 如果消息是本程序发送的\n        if (msg.what == MSG_WHAT) {\n            mClipDrawable.setLevel(mProgress);\n        }\n    }\n};\n.......\nRunnable mRunnable = new Runnable() {\n\t@Override\n    public void run() {\n        isRunning = true;\n        while (isRunning) {\n            handler.sendEmptyMessage(MSG_WHAT);\n            if (mProgress > MAX_PROGRESS) {\n                mProgress = 0;\n            }\n            mProgress += 100;\n            try {\n                Thread.sleep(18);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n};\n```\n","slug":"2015.07.07 - 知其所以然","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dy00002tfpt35f428x1"},{"title":"扯扯线程并发和同步的那些事","date":"2015-06-26T23:04:29.000Z","_content":"\n\n## 扯扯线程并发和同步的那些事 2015.6.26\n\n### 线程基础的那些事——李仙鹏\n\n#### 线程\n\n线程俗称为轻量级进程。在现代OS中，通常以线程作为基本的调度单位。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程又有各自的程序计数器、栈以及局部变量等。因此，再配合多核CPU，多个线程方可被并发执行。\n\n##### 线程的上下文切换\n\n如果当前运行线程数与CPU核数相同，那么这些线程将不会被系统调度出去。\n\n但是，如果可运行的线程数量大于CPU核数，那么系统会通过上下文切换，将某个正在运行的线程调度出来，从而使其他线程能够获得CPU的时间片，从而得到运行。\n\n**上下文切换需要一定的开销：**\n\n1. 系统和应用程序都使用一组相同的CPU，线程调度需要访问系统资源。系统代码消耗越多的CPU时间，分配到应用程序的可用CPU时间就越少。\n2. 上下文切换会导致处理器的一些缓存缺失\n\n> 线程的以上特性，促使了现代编程的并发和同步问题：\n> \n> * 安全性问题。安全性的含义是“永远不会发生糟糕的事情”\n> * 活跃性问题。活跃性关注的目标为“某件正确的事情最终会发生”\n> * 性能问题。性能关注的点事“正确的事情尽快发生”\n\n#### 超线程（Hyper-Threading）\n\n为何我们会经常听到宣传说：四核八线程并行（如I5处理器）、八核十六线程并行（如I7）。原因是，这些CPU使用了超线程技术。超线程最早由因特尔研发，并在奔腾四处理器将技术主流化。\n\n超线程技术是在CPU内部仅复制必要的资源、让CPU模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作，模拟实体双核心、双线程运作。\n\n虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。\n\n#### GUI为什么都是单线程\n\n许多人曾经尝试过编写多线程的GUI来处理事件，但最终都由于竞态条件和死锁导致的稳定性而重回到单线程的事件队列模型：使用UI线程从队列中抽取事件，并将事件分发给事件处理器（消费者）。\n\n另一个重要原因是MVC会导致多线程的GUI因为不一致的锁定顺序而发生死锁。\n![MVC模式图](http://www.51cto.com/files/uploadimg/20061010/1202170.gif)\n\n#### 推荐两本书\n\n> **值得一看：**\n\n> * [深入理解计算机系统](http://book.douban.com/subject/5333562/)\n> * [Java并发编程实战](http://book.douban.com/subject/10484692/)\n\n### JAVA多线程中的单例——贾学涛 \n\n#### 常见单利模写法\n\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 缺点：非线程安全的，在多线程并发的情况下容易出现多个实例存在的情况\n\n#### 改为线程安全的单例模式\n通过添加synchronized关键字  \n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static synchronized Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 缺点：每次都要进行同步检查，实际上需要检查的时机是在首次创建实例的时候。\n\n#### 改为双重检查锁单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* instance = new Singleton()这句，并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情  \n\n\t> 1.给 instance 分配内存  \n\t> 2.调用 Singleton 的构造函数来初始化成员变量  \n\t> 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  \n\n\t但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的.可能会出现第一次检测是mInstance为非null时，有可能实例还未创建。所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n#### 为实例变量增加volatile关键字\n\n\tpublic class Singleton {  \n\n\t\tprivate volatile static Singleton mInstance；    // 增加volatile关键字\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前\n\n* Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序\n\n\n#### 饿汉加载单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance ＝ new Singleton()；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n变种的饿汉加载单例模式\n\n\tpublic class Singleton {\n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tstatic {\n\t\t\tmInstance = new Singleton();\n\t\t}\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 缺点：在类被加载的时候就会去创建实例，牺牲空间来保证时间，与之前的单例模式相反，懒汉加载是牺牲时间，来保证空间，在需要的时候再去创建实例。\n\n#### 通过静态内部类来创建单例\n\n\tpublic class Singleton {\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn InnerClass.mInstance;\n\t\t}\n\t\t\n\t\tprivate staitc class InnerClass{\n\t\t\tpublic static Singleton mInstance = new Singleton();\n\t\t}\n\t}\n* 与前者一样，通过classloader机制来保证线程安全，区别是，前者当Singleton类被加载时，就会创建实例，而后者是在需要调用getInstance的时候去加载内部类的时候，来创建实例。\n\n#### 通过枚举来创建单例\n\n\tpublic enum Singleton {\n\t\tINSTANCE;\n\t}\n\n访问实例对象 Singleton.INSTANCE\n\n*默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。\n\n### 为什么要有线程同步之喂金鱼问题——曾铭\n\n#### 喂金鱼问题\n- 金鱼一天不吃会饿死，一天吃两次会撑死；\n- 张三、李四，每天每人分别会去执行这件事一次；\n\n#### 方案 1\n\n两人执行一致\n\n```\nif (noFeed) {\n\tfeed fish\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- feed fish 时间越长，鱼被撑死可能性越大\n- 没解决问题\n\n#### 方案 2\n\n两人执行一致\n\n```\nif (noNote) {\n\tleave note\n\t\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n\t\n\tremove note\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noNote) {\t\t| .\n. \t\t\t\t\t| if (noNote) {\n.\t\t\t\t\t| leave note\nleave note\t\t\t| .\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- noNote, noFeed 按特定顺序执行才会出问题\n- noNote 多了一层保护，如果 leave note 时间很短，出问题可能性很小\n- 没解决问题\n\n\n#### 方案 3\n\n张三执行\n\n```\nleave note3\n\nif (noNote4) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n张三  | 李四\n--- | ---\nleave note3\t\t| .\n. \t\t\t\t\t| leave note4\n.\t\t\t\t\t| if (noNote3) {\nif (noNote4) {\t| .\nremove note3\t| .\n. \t\t\t\t\t| remove note4\n...\t\t\t\t\t| ...\nfish died\t\t\t| .\n\n##### 结论\n- 不会被撑死了，可能会被饿死……\n- 没解决问题\n\n#### 方案 4\n\n张三执行\n\n```\nleave note3\n\nwhile (noNote4)\n{\n\tsleep (1)\n}\n\nif (noFeed) {\n\tfeed fish\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n##### 结论\n- 的确解决了问题\n- 能优化么？\n\t- 程序不不对称\n\t- 循环等待的浪费\n\n#### 方案 5\n\n两人执行一致\n\n```\nlock()\n\nif (noFeed) {\n\tfeed fish\n}\n\nunlock()\n\n```\n\n##### 总结\n- 能解决问题\n- 程序对称\n- 持有锁需要等待，未解决浪费问题\n\t- 生产者与消费者问题\n\n#### END\n\n**全部内容来自[《计算机的心智·操作系统之哲学原理》——\u0004邹恒明](http://book.douban.com/subject/3670621/) 第七章**\n\n### iOS并发相关的概念介绍——潘君 \n@(归纳中)[iOS]\n\n#### 基础概念\n#####竞态条件\n竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。\n竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。\n\n注: `atomic` 可以解决竞态竞争 但是无法保证类是`线程安全`的\n\n#### iOS中的相关概念\n#####atomic属性\n\n> property 修饰符\n\n加了atomic后生成的setter,类似如下代码:    \n\n```\n- (void)setProp:(NSString *)newValue {   \n    [_prop lock];   \n    _prop = newValue;   \n    [_prop unlock];   \n}   \n```\n\n\n#####@synchronized指令\n\n> 引用自[@synchronized(id anObject) ｛｝定义和使用](http://www.xuebuyuan.com/1682784.html)\n> 1.作用：创建了一个互斥锁，它的作用和其他语言中的互斥锁作用一样\n\n> 2.解释：这个是OBC中的一个锁定令牌，防止｛｝里的内容在同一时间内被其他线程访问，起到了线程保护的作用\n\n> 3.使用范围：一般在单例模式或者操作类的static变量的时候使用，即共用的变量的时候\n\n> 4.外延：这个令牌隐式的包含了异常处理，如果你不想使用的话，就使用锁吧\n\n> 5.它的参数是id类型，如果用\n> @synchronized(1) {\n> }\n> 编译器提示\n> @synchronzied requires an Objective-C object type.\n> 也就是说需要一个objective C的对象类型。\n\n```\n@synchronized(id anObject){\n\t // test code\n}\n```\n\n#####NSLock\n\n使用样例:\n\n```\n//主线程中\nTestObj *obj = [[TestObj alloc] init];\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [lock lock];\n    [obj method1];\n    sleep(10);\n    [lock unlock];\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    sleep(1);//以保证让线程2的代码后执行\n    [lock lock];\n    [obj method2];\n    [lock unlock];\n});\n```\n\n\n###[iOS多线程](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html) - 杨志平\n\n####简介\n\niOS有三种多线程编程的技术，分别是：\n\n- #### NSThread \n- #### Cocoa NSOperation\n- #### GCD ***（全称：Grand Central Dispatch）***\n \n>  *这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的*\n\n \n#### 三种方式的介绍：\n##### NSThread - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/)\n> 优点：NSThread 比其他两个轻量级 \n> 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销\n \n##### NSOperation - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/)\n> 优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。\n>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。\n \n##### GCD - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html)\n> Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。\n\n \n>GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。\n\n\n#### 创建线程的开销 - [查看文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)\nItem | Approximate cost | Notes\n----- | ----- | -----\nKernel data structures   |  Approximately 1 KB  |  This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.\nStack space | 512 KB (secondary threads)  8 MB (OS X main thread)  1 MB (iOS main thread) | The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed.\nCreation time | Approximately 90 microseconds | This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.\n\n\n#### 替代线程的一些技术\n\nItem | Approximate cost \n----- | ----- \nOperation objects | Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091).\nGrand Central Dispatch (GCD) | Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)\nIdle-time notifications | For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default [NSNotificationQueue](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/occ/cl/NSNotificationQueue) object using the [NSPostWhenIdle](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/c/econst/NSPostWhenIdle) option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see [Notification Programming Topics](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i).\nAsynchronous functions | The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread\nTimers | You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see [Timer Sources](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21)\nSeparate processes | Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user\n\n#### 线程安全 - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)\n\n##### 原则\n- Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately. \n- Many objects deemed “thread-unsafe” are only unsafe to use from multiple threads. Many of these objects can be used from any thread as long as it is only one thread at a time. Objects that are specifically restricted to the main thread of an application are called out as such\n- The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence\n- If you want to use a thread to draw to a view, bracket all drawing code between the ***lockFocusIfCanDraw*** and ***unlockFocus*** methods of NSView\n\n##### Thread-Safe Classes and Functions\nThe following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.\n> NSArray\nNSAssertionHandler\nNSAttributedString\nNSCalendarDate\nNSCharacterSet\nNSConditionLock\nNSConnection\nNSData\nNSDate\nNSDecimal functions\nNSDecimalNumber\nNSDecimalNumberHandler\nNSDeserializer\nNSDictionary\nNSDistantObject\nNSDistributedLock\nNSDistributedNotificationCenter\nNSException\nNSFileManager (in OS X v10.5 and later)\nNSHost\nNSLock\nNSLog/NSLogv\nNSMethodSignature\nNSNotification\nNSNotificationCenter\nNSNumber\nNSObject\nNSPortCoder\nNSPortMessage\nNSPortNameServer\nNSProtocolChecker\nNSProxy\nNSRecursiveLock\nNSSet\nNSString\nNSThread\nNSTimer\nNSTimeZone\nNSUserDefaults\nNSValue\n\n##### Thread-Unsafe Classes\nThe following classes and functions are generally not thread-safe. In most cases, you can use these classes from any thread as long as you use them from only one thread at a time. \n\n>NSArchiver\nNSAutoreleasePool\nNSBundle\nNSCalendar\nNSCoder\nNSCountedSet\nNSDateFormatter\nNSEnumerator\nNSFileHandle\nNSFormatter\nNSHashTable functions\nNSInvocation\nNSJavaSetup functions\nNSMapTable functions\nNSMutableArray\nNSMutableAttributedString\nNSMutableCharacterSet\nNSMutableData\nNSMutableDictionary\nNSMutableSet\nNSMutableString\nNSNotificationQueue\nNSNumberFormatter\nNSPipe\nNSPort\nNSProcessInfo\nNSRunLoop\nNSScanner\nNSSerializer\nNSTask\nNSUnarchiver\nNSUndoManager\n\n#####Main Thread Only Classes\n\nThe following class must be used only from the main thread of an application.\n\n> NSAppleScript\n\n### 多线程的死锁 - 张超耀\n- 俗话说，人多好办事！在程序里也是这样，如果是同一个应用程序需要并行处理多件任务，那就可以创建多条线程。但是人多了，往往会出现冲突，使得这个工作无法再进行下去了(正所谓三个和尚没水喝)，这就是“死锁”。\n\n#### 死锁的产生\n- [哲学家进餐问题](http://baike.baidu.com/link?url=OgOrpH_xTP7U0C0tM59aBhq83uaKe0Ck9MQEL1G41A3q-D1hVuynm3ra-U93RoQICKbmqhs7nTuCoN_elydnr_)\n\n**那么我们如何来消除“死锁”呢？首先，让我们来看看产生“死锁”的必要条件：** \n\n- 互斥：就是说多个线程不能同时使用同一资源 \n\n- 请求和保持：就是某线程必须同时拥有多个资源才能完成任务，否则它将占用已经拥有的资源直到拥有他所需的所有资源为止\n\n- 不剥夺：就是说所有线程的优先级都相同，不能在别的线程没有释放资源的情况下，夺走其已占有的资源 \n\n- 循环等待，就是没有资源满足的线程无限期地等待\n\n**有的朋友可能已经明白了，只要打破这这几个必要条件，就能打破“死锁”！**\n\n- 互斥：就是要让多个线程能共享资源 \n\n- 请求和保持：只要当检测到自己所需的资源仍被别的线程占用，即释放自己已占有的资源（毫不利己，专门利人），或者在经过一段时间的等待后，还未得到所需资源，才释放，这都能打破请求和保持\n\n- 不剥夺：只要给线程制定一个优先级即可\n\n- 最后的循环等待的解决方法其实和`请求和保持`是一样的，都是等待一段时间后释放资源。\n\n**好了，希望通过这个例子能让不了解死锁的朋友对“死锁”能有一定的认识**\n\n## 集合的并行操作 - 王胜\n\n用for循环操作一个集合，即读取集合元素，同时又删除集合中的元素，会发生什么事情呢？\n\n上代码【号外，号外，此示例来源于我们项目中的真实代码哦~】\n\n```Java\n// Target class\nclass Target {\n\tint id;// ID\n\tString type;// 类型\n\tint count;// 未读消息数\n\t\n\tpublic Target(int id, String type, int count) {\n\t\tthis.id = id;\n\t\tthis.type = type;\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Target [id=\" + id + \", type=\" + type + \", count=\" + count + \"]\";\n\t}\n\t\n}\n\n// 以下是模拟一组target集合，target包含group、room、user类型。\nList<Target> sessions = new ArrayList<Target>();\nsessions.add(new Target(1, \"group\", 1));\nsessions.add(new Target(2, \"group\", 1));\nsessions.add(new Target(3, \"group\", 1));\nsessions.add(new Target(4, \"room\", 1));\nsessions.add(new Target(5, \"group\", 1));\nsessions.add(new Target(6, \"group\", 1));\nsessions.add(new Target(7, \"group\", 1));\nsessions.add(new Target(8, \"user\", 1));\nsessions.add(new Target(9, \"user\", 1));\nsessions.add(new Target(10, \"group\", 1));\nSystem.out.println(\"before size:\"+sessions.size()+\", sessions:\"+humanPrintList(sessions));\nint totalUnread = 0;// 统计集合中类型为group的target未读消息数量\nfor (int i=0;i<sessions.size();i++) {\n\tSystem.out.println(\"read index:\" + i + \", session:\"+sessions.get(i));\n\tif (sessions.get(i).type.equals(\"group\")) {// 如果是group类型，则累加未读消息数\n\t\tSystem.out.println(\"==> add totalUnread\");\n\t\ttotalUnread += sessions.get(i).count;\n\t} else {// 否则，将target移除集合\n\t\tSystem.out.println(\"==> remove\");\n\t\tsessions.remove(i);\n\t}\n}\nSystem.out.println(\"after size:\"+sessions.size()+\", totalUnread:\"+totalUnread+\",sessions:\"+humanPrintList(sessions));\n```\n\n至此，示例代码结束。大家可以猜测下最后的输出中sessions的长度，内容以及总共的未读消息数据。\n\n项目中的代码，期望结果是剩余集合只包含group类型的target，而且totalUnread的值是类型为group的target的未读消息数之和。可是，运行的结果却是：\n\n```\nbefore size:10, sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=4, type=room, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=8, type=user, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\nread index:0, session:Target [id=1, type=group, count=1]\n==> add totalUnread\nread index:1, session:Target [id=2, type=group, count=1]\n==> add totalUnread\nread index:2, session:Target [id=3, type=group, count=1]\n==> add totalUnread\nread index:3, session:Target [id=4, type=room, count=1]\n==> remove\nread index:4, session:Target [id=6, type=group, count=1]\n==> add totalUnread\nread index:5, session:Target [id=7, type=group, count=1]\n==> add totalUnread\nread index:6, session:Target [id=8, type=user, count=1]\n==> remove\nread index:7, session:Target [id=10, type=group, count=1]\n==> add totalUnread\nafter size:8, totalUnread:6,sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\n```\n\n为什么结果完全不是预期的呢？原因是程序走到else时，将元素移除，后面的元素自动往前移动，所以继续取下一个下标时，被移除的后一个元素悄悄溜走了，成了漏网之鱼。\n\n**解决方法** : 最简单的就是在remove后执行 ```i--; ```\n","source":"_posts/2015.06.26 - 线程并发和同步.md","raw":"title: 扯扯线程并发和同步的那些事\ndate: 2015-06-26 23:04:29\ntags:\n- 线程\n- 同步异步\n\n---\n\n\n## 扯扯线程并发和同步的那些事 2015.6.26\n\n### 线程基础的那些事——李仙鹏\n\n#### 线程\n\n线程俗称为轻量级进程。在现代OS中，通常以线程作为基本的调度单位。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程又有各自的程序计数器、栈以及局部变量等。因此，再配合多核CPU，多个线程方可被并发执行。\n\n##### 线程的上下文切换\n\n如果当前运行线程数与CPU核数相同，那么这些线程将不会被系统调度出去。\n\n但是，如果可运行的线程数量大于CPU核数，那么系统会通过上下文切换，将某个正在运行的线程调度出来，从而使其他线程能够获得CPU的时间片，从而得到运行。\n\n**上下文切换需要一定的开销：**\n\n1. 系统和应用程序都使用一组相同的CPU，线程调度需要访问系统资源。系统代码消耗越多的CPU时间，分配到应用程序的可用CPU时间就越少。\n2. 上下文切换会导致处理器的一些缓存缺失\n\n> 线程的以上特性，促使了现代编程的并发和同步问题：\n> \n> * 安全性问题。安全性的含义是“永远不会发生糟糕的事情”\n> * 活跃性问题。活跃性关注的目标为“某件正确的事情最终会发生”\n> * 性能问题。性能关注的点事“正确的事情尽快发生”\n\n#### 超线程（Hyper-Threading）\n\n为何我们会经常听到宣传说：四核八线程并行（如I5处理器）、八核十六线程并行（如I7）。原因是，这些CPU使用了超线程技术。超线程最早由因特尔研发，并在奔腾四处理器将技术主流化。\n\n超线程技术是在CPU内部仅复制必要的资源、让CPU模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作，模拟实体双核心、双线程运作。\n\n虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。\n\n#### GUI为什么都是单线程\n\n许多人曾经尝试过编写多线程的GUI来处理事件，但最终都由于竞态条件和死锁导致的稳定性而重回到单线程的事件队列模型：使用UI线程从队列中抽取事件，并将事件分发给事件处理器（消费者）。\n\n另一个重要原因是MVC会导致多线程的GUI因为不一致的锁定顺序而发生死锁。\n![MVC模式图](http://www.51cto.com/files/uploadimg/20061010/1202170.gif)\n\n#### 推荐两本书\n\n> **值得一看：**\n\n> * [深入理解计算机系统](http://book.douban.com/subject/5333562/)\n> * [Java并发编程实战](http://book.douban.com/subject/10484692/)\n\n### JAVA多线程中的单例——贾学涛 \n\n#### 常见单利模写法\n\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 缺点：非线程安全的，在多线程并发的情况下容易出现多个实例存在的情况\n\n#### 改为线程安全的单例模式\n通过添加synchronized关键字  \n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static synchronized Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 缺点：每次都要进行同步检查，实际上需要检查的时机是在首次创建实例的时候。\n\n#### 改为双重检查锁单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* instance = new Singleton()这句，并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情  \n\n\t> 1.给 instance 分配内存  \n\t> 2.调用 Singleton 的构造函数来初始化成员变量  \n\t> 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  \n\n\t但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的.可能会出现第一次检测是mInstance为非null时，有可能实例还未创建。所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n#### 为实例变量增加volatile关键字\n\n\tpublic class Singleton {  \n\n\t\tprivate volatile static Singleton mInstance；    // 增加volatile关键字\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前\n\n* Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序\n\n\n#### 饿汉加载单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance ＝ new Singleton()；\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n变种的饿汉加载单例模式\n\n\tpublic class Singleton {\n\n\t\tprivate static Singleton mInstance；\n\t\n\t\tstatic {\n\t\t\tmInstance = new Singleton();\n\t\t}\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\t\t\n\t\t}\n\t}\n\n* 缺点：在类被加载的时候就会去创建实例，牺牲空间来保证时间，与之前的单例模式相反，懒汉加载是牺牲时间，来保证空间，在需要的时候再去创建实例。\n\n#### 通过静态内部类来创建单例\n\n\tpublic class Singleton {\n\t\n\t\tprivate Singleton(){\n\t\t}\n\t\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn InnerClass.mInstance;\n\t\t}\n\t\t\n\t\tprivate staitc class InnerClass{\n\t\t\tpublic static Singleton mInstance = new Singleton();\n\t\t}\n\t}\n* 与前者一样，通过classloader机制来保证线程安全，区别是，前者当Singleton类被加载时，就会创建实例，而后者是在需要调用getInstance的时候去加载内部类的时候，来创建实例。\n\n#### 通过枚举来创建单例\n\n\tpublic enum Singleton {\n\t\tINSTANCE;\n\t}\n\n访问实例对象 Singleton.INSTANCE\n\n*默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。\n\n### 为什么要有线程同步之喂金鱼问题——曾铭\n\n#### 喂金鱼问题\n- 金鱼一天不吃会饿死，一天吃两次会撑死；\n- 张三、李四，每天每人分别会去执行这件事一次；\n\n#### 方案 1\n\n两人执行一致\n\n```\nif (noFeed) {\n\tfeed fish\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- feed fish 时间越长，鱼被撑死可能性越大\n- 没解决问题\n\n#### 方案 2\n\n两人执行一致\n\n```\nif (noNote) {\n\tleave note\n\t\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n\t\n\tremove note\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noNote) {\t\t| .\n. \t\t\t\t\t| if (noNote) {\n.\t\t\t\t\t| leave note\nleave note\t\t\t| .\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- noNote, noFeed 按特定顺序执行才会出问题\n- noNote 多了一层保护，如果 leave note 时间很短，出问题可能性很小\n- 没解决问题\n\n\n#### 方案 3\n\n张三执行\n\n```\nleave note3\n\nif (noNote4) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n张三  | 李四\n--- | ---\nleave note3\t\t| .\n. \t\t\t\t\t| leave note4\n.\t\t\t\t\t| if (noNote3) {\nif (noNote4) {\t| .\nremove note3\t| .\n. \t\t\t\t\t| remove note4\n...\t\t\t\t\t| ...\nfish died\t\t\t| .\n\n##### 结论\n- 不会被撑死了，可能会被饿死……\n- 没解决问题\n\n#### 方案 4\n\n张三执行\n\n```\nleave note3\n\nwhile (noNote4)\n{\n\tsleep (1)\n}\n\nif (noFeed) {\n\tfeed fish\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n##### 结论\n- 的确解决了问题\n- 能优化么？\n\t- 程序不不对称\n\t- 循环等待的浪费\n\n#### 方案 5\n\n两人执行一致\n\n```\nlock()\n\nif (noFeed) {\n\tfeed fish\n}\n\nunlock()\n\n```\n\n##### 总结\n- 能解决问题\n- 程序对称\n- 持有锁需要等待，未解决浪费问题\n\t- 生产者与消费者问题\n\n#### END\n\n**全部内容来自[《计算机的心智·操作系统之哲学原理》——\u0004邹恒明](http://book.douban.com/subject/3670621/) 第七章**\n\n### iOS并发相关的概念介绍——潘君 \n@(归纳中)[iOS]\n\n#### 基础概念\n#####竞态条件\n竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。\n竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。\n\n注: `atomic` 可以解决竞态竞争 但是无法保证类是`线程安全`的\n\n#### iOS中的相关概念\n#####atomic属性\n\n> property 修饰符\n\n加了atomic后生成的setter,类似如下代码:    \n\n```\n- (void)setProp:(NSString *)newValue {   \n    [_prop lock];   \n    _prop = newValue;   \n    [_prop unlock];   \n}   \n```\n\n\n#####@synchronized指令\n\n> 引用自[@synchronized(id anObject) ｛｝定义和使用](http://www.xuebuyuan.com/1682784.html)\n> 1.作用：创建了一个互斥锁，它的作用和其他语言中的互斥锁作用一样\n\n> 2.解释：这个是OBC中的一个锁定令牌，防止｛｝里的内容在同一时间内被其他线程访问，起到了线程保护的作用\n\n> 3.使用范围：一般在单例模式或者操作类的static变量的时候使用，即共用的变量的时候\n\n> 4.外延：这个令牌隐式的包含了异常处理，如果你不想使用的话，就使用锁吧\n\n> 5.它的参数是id类型，如果用\n> @synchronized(1) {\n> }\n> 编译器提示\n> @synchronzied requires an Objective-C object type.\n> 也就是说需要一个objective C的对象类型。\n\n```\n@synchronized(id anObject){\n\t // test code\n}\n```\n\n#####NSLock\n\n使用样例:\n\n```\n//主线程中\nTestObj *obj = [[TestObj alloc] init];\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [lock lock];\n    [obj method1];\n    sleep(10);\n    [lock unlock];\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    sleep(1);//以保证让线程2的代码后执行\n    [lock lock];\n    [obj method2];\n    [lock unlock];\n});\n```\n\n\n###[iOS多线程](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html) - 杨志平\n\n####简介\n\niOS有三种多线程编程的技术，分别是：\n\n- #### NSThread \n- #### Cocoa NSOperation\n- #### GCD ***（全称：Grand Central Dispatch）***\n \n>  *这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的*\n\n \n#### 三种方式的介绍：\n##### NSThread - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/)\n> 优点：NSThread 比其他两个轻量级 \n> 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销\n \n##### NSOperation - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/)\n> 优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。\n>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。\n \n##### GCD - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html)\n> Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。\n\n \n>GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。\n\n\n#### 创建线程的开销 - [查看文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)\nItem | Approximate cost | Notes\n----- | ----- | -----\nKernel data structures   |  Approximately 1 KB  |  This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.\nStack space | 512 KB (secondary threads)  8 MB (OS X main thread)  1 MB (iOS main thread) | The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed.\nCreation time | Approximately 90 microseconds | This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.\n\n\n#### 替代线程的一些技术\n\nItem | Approximate cost \n----- | ----- \nOperation objects | Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091).\nGrand Central Dispatch (GCD) | Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)\nIdle-time notifications | For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default [NSNotificationQueue](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/occ/cl/NSNotificationQueue) object using the [NSPostWhenIdle](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/c/econst/NSPostWhenIdle) option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see [Notification Programming Topics](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i).\nAsynchronous functions | The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread\nTimers | You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see [Timer Sources](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21)\nSeparate processes | Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user\n\n#### 线程安全 - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)\n\n##### 原则\n- Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately. \n- Many objects deemed “thread-unsafe” are only unsafe to use from multiple threads. Many of these objects can be used from any thread as long as it is only one thread at a time. Objects that are specifically restricted to the main thread of an application are called out as such\n- The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence\n- If you want to use a thread to draw to a view, bracket all drawing code between the ***lockFocusIfCanDraw*** and ***unlockFocus*** methods of NSView\n\n##### Thread-Safe Classes and Functions\nThe following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.\n> NSArray\nNSAssertionHandler\nNSAttributedString\nNSCalendarDate\nNSCharacterSet\nNSConditionLock\nNSConnection\nNSData\nNSDate\nNSDecimal functions\nNSDecimalNumber\nNSDecimalNumberHandler\nNSDeserializer\nNSDictionary\nNSDistantObject\nNSDistributedLock\nNSDistributedNotificationCenter\nNSException\nNSFileManager (in OS X v10.5 and later)\nNSHost\nNSLock\nNSLog/NSLogv\nNSMethodSignature\nNSNotification\nNSNotificationCenter\nNSNumber\nNSObject\nNSPortCoder\nNSPortMessage\nNSPortNameServer\nNSProtocolChecker\nNSProxy\nNSRecursiveLock\nNSSet\nNSString\nNSThread\nNSTimer\nNSTimeZone\nNSUserDefaults\nNSValue\n\n##### Thread-Unsafe Classes\nThe following classes and functions are generally not thread-safe. In most cases, you can use these classes from any thread as long as you use them from only one thread at a time. \n\n>NSArchiver\nNSAutoreleasePool\nNSBundle\nNSCalendar\nNSCoder\nNSCountedSet\nNSDateFormatter\nNSEnumerator\nNSFileHandle\nNSFormatter\nNSHashTable functions\nNSInvocation\nNSJavaSetup functions\nNSMapTable functions\nNSMutableArray\nNSMutableAttributedString\nNSMutableCharacterSet\nNSMutableData\nNSMutableDictionary\nNSMutableSet\nNSMutableString\nNSNotificationQueue\nNSNumberFormatter\nNSPipe\nNSPort\nNSProcessInfo\nNSRunLoop\nNSScanner\nNSSerializer\nNSTask\nNSUnarchiver\nNSUndoManager\n\n#####Main Thread Only Classes\n\nThe following class must be used only from the main thread of an application.\n\n> NSAppleScript\n\n### 多线程的死锁 - 张超耀\n- 俗话说，人多好办事！在程序里也是这样，如果是同一个应用程序需要并行处理多件任务，那就可以创建多条线程。但是人多了，往往会出现冲突，使得这个工作无法再进行下去了(正所谓三个和尚没水喝)，这就是“死锁”。\n\n#### 死锁的产生\n- [哲学家进餐问题](http://baike.baidu.com/link?url=OgOrpH_xTP7U0C0tM59aBhq83uaKe0Ck9MQEL1G41A3q-D1hVuynm3ra-U93RoQICKbmqhs7nTuCoN_elydnr_)\n\n**那么我们如何来消除“死锁”呢？首先，让我们来看看产生“死锁”的必要条件：** \n\n- 互斥：就是说多个线程不能同时使用同一资源 \n\n- 请求和保持：就是某线程必须同时拥有多个资源才能完成任务，否则它将占用已经拥有的资源直到拥有他所需的所有资源为止\n\n- 不剥夺：就是说所有线程的优先级都相同，不能在别的线程没有释放资源的情况下，夺走其已占有的资源 \n\n- 循环等待，就是没有资源满足的线程无限期地等待\n\n**有的朋友可能已经明白了，只要打破这这几个必要条件，就能打破“死锁”！**\n\n- 互斥：就是要让多个线程能共享资源 \n\n- 请求和保持：只要当检测到自己所需的资源仍被别的线程占用，即释放自己已占有的资源（毫不利己，专门利人），或者在经过一段时间的等待后，还未得到所需资源，才释放，这都能打破请求和保持\n\n- 不剥夺：只要给线程制定一个优先级即可\n\n- 最后的循环等待的解决方法其实和`请求和保持`是一样的，都是等待一段时间后释放资源。\n\n**好了，希望通过这个例子能让不了解死锁的朋友对“死锁”能有一定的认识**\n\n## 集合的并行操作 - 王胜\n\n用for循环操作一个集合，即读取集合元素，同时又删除集合中的元素，会发生什么事情呢？\n\n上代码【号外，号外，此示例来源于我们项目中的真实代码哦~】\n\n```Java\n// Target class\nclass Target {\n\tint id;// ID\n\tString type;// 类型\n\tint count;// 未读消息数\n\t\n\tpublic Target(int id, String type, int count) {\n\t\tthis.id = id;\n\t\tthis.type = type;\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Target [id=\" + id + \", type=\" + type + \", count=\" + count + \"]\";\n\t}\n\t\n}\n\n// 以下是模拟一组target集合，target包含group、room、user类型。\nList<Target> sessions = new ArrayList<Target>();\nsessions.add(new Target(1, \"group\", 1));\nsessions.add(new Target(2, \"group\", 1));\nsessions.add(new Target(3, \"group\", 1));\nsessions.add(new Target(4, \"room\", 1));\nsessions.add(new Target(5, \"group\", 1));\nsessions.add(new Target(6, \"group\", 1));\nsessions.add(new Target(7, \"group\", 1));\nsessions.add(new Target(8, \"user\", 1));\nsessions.add(new Target(9, \"user\", 1));\nsessions.add(new Target(10, \"group\", 1));\nSystem.out.println(\"before size:\"+sessions.size()+\", sessions:\"+humanPrintList(sessions));\nint totalUnread = 0;// 统计集合中类型为group的target未读消息数量\nfor (int i=0;i<sessions.size();i++) {\n\tSystem.out.println(\"read index:\" + i + \", session:\"+sessions.get(i));\n\tif (sessions.get(i).type.equals(\"group\")) {// 如果是group类型，则累加未读消息数\n\t\tSystem.out.println(\"==> add totalUnread\");\n\t\ttotalUnread += sessions.get(i).count;\n\t} else {// 否则，将target移除集合\n\t\tSystem.out.println(\"==> remove\");\n\t\tsessions.remove(i);\n\t}\n}\nSystem.out.println(\"after size:\"+sessions.size()+\", totalUnread:\"+totalUnread+\",sessions:\"+humanPrintList(sessions));\n```\n\n至此，示例代码结束。大家可以猜测下最后的输出中sessions的长度，内容以及总共的未读消息数据。\n\n项目中的代码，期望结果是剩余集合只包含group类型的target，而且totalUnread的值是类型为group的target的未读消息数之和。可是，运行的结果却是：\n\n```\nbefore size:10, sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=4, type=room, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=8, type=user, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\nread index:0, session:Target [id=1, type=group, count=1]\n==> add totalUnread\nread index:1, session:Target [id=2, type=group, count=1]\n==> add totalUnread\nread index:2, session:Target [id=3, type=group, count=1]\n==> add totalUnread\nread index:3, session:Target [id=4, type=room, count=1]\n==> remove\nread index:4, session:Target [id=6, type=group, count=1]\n==> add totalUnread\nread index:5, session:Target [id=7, type=group, count=1]\n==> add totalUnread\nread index:6, session:Target [id=8, type=user, count=1]\n==> remove\nread index:7, session:Target [id=10, type=group, count=1]\n==> add totalUnread\nafter size:8, totalUnread:6,sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\n```\n\n为什么结果完全不是预期的呢？原因是程序走到else时，将元素移除，后面的元素自动往前移动，所以继续取下一个下标时，被移除的后一个元素悄悄溜走了，成了漏网之鱼。\n\n**解决方法** : 最简单的就是在remove后执行 ```i--; ```\n","slug":"2015.06.26 - 线程并发和同步","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dy20003tfptoxus6emq"},{"title":"代码开发效率提升方法","date":"2015-06-19T23:04:29.000Z","_content":"\n## 2015.06.19 - 技术分享，主题\"代码开发效率提升方法\"\n#### snippet的制作与使用 - 杨志平\n\n#####备份路径\n> ~/Library/Developer/Xcode/UserData/CodeSnippets/\n\n#####界面\n![image](http://static.oschina.net/uploads/space/2014/0306/145357_xj9O_868062.png)\n\n#####使用\n\n###### 1.系统自带\n\n很多我们的代码提示都是snippet系统已经有的代码块如：\nblock变量定义\n\n> typedef <#returnType#>(^<#name#>)(<#arguments#>);\n\n###### 2.常用变量\n- strong\n- weak\n- assign\n- block\n\n###### 3.常用方法\n- 比如：hiddenKeyBoard\n- 网络请求：getData\n- 上下拉刷新，等等\n\n###### 4.常用模块\n- 常用的代理协议方法集\n\n\n\n#####制作\n选中代码块拖入snippet library即可。为了方便调用可简单编辑\n\n![image2](http://static.oschina.net/uploads/space/2014/0306/143716_p6Kl_868062.png)\n\n#####PaintCode的简单使用\n\n简单的图形绘制，可像xib一样拖拽图形，并添加到view的CALayer层上\n\n- drawRect方法\n\n#### myEclipse分享 - 吴明\n - myEclipse主要WebService开发工具\n \n - MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。\n\n - [myEclipse使用ssh框架](http://www.cnblogs.com/younes/archive/2011/12/21/2295759.html)\n \t\n - myEclipse常用快捷键\n \t- Alt+Shift+s:\n \t\t打开myEclipse快捷键菜单\n\t\t- 自动生成get set方法\n\t\t- 自动生成无参和有参构造方法\n \t- Ctrl+D：删除当前行 \n \t- Ctrl+Alt+↓：复制当前行到下一行(复制增加)\n \t- Ctrl+Alt+↑：复制当前行到上一行(复制增加)\n \t- Alt+↓：当前行和下面一行交互位置\n \t- Alt+↑：当前行和上面一行交互位置\n \t- Ctrl+Shift+O：快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类\n - [ssh框架](http://baike.baidu.com/link?url=-FpesVZmaLqL3GJTVfPriU4jZQlvjIWKgbmy1lxgSlzT83WVAbFUA952pclZJbIkqzDTWVc7L-dTBalJjXTNH_)\n\n#### OSX 快捷键入门 - 曾铭\n\n##### OSX 系统级的快捷键支持\n\n- 统一标准的全局快捷键：如 FX、『设置』、opt\n\t- [一些『奇怪的』符号](https://support.apple.com/kb/PH18802?locale=zh_CN&viewlocale=zh_CN)\n\t- [Mac 键盘快捷键](https://support.apple.com/zh-cn/HT201236)\n\t- 有时，略略隐晦了些：如截图、奇葩的 cmd+tab,opt\n- 在统一之外，留意每个应用的快捷键：如 chrome：opt+cmd+i，cmd+l\n\t\n##### 讨论常用快捷键 （具体快捷键请自己查）\n\n- 设置\n- 剪切复制粘贴全选\n- 新建、新建 tab、切换 tab、关闭 tab、关闭应用\n- 光标的自由游走\n    - 上下左右（推荐 hjkl）、字符移动、行首行尾、文首文尾、向后删除、单词删除、行向前向后删除\n- Xcode\n\t- 上下移行 （@志平 推荐）\n\t- reveal to project navigator、切换 .h.m 文件\n\t- 显示隐藏 navigatiors、Debug area、Utilities\n\t- new tab、切换 tab、分割窗口\n\n##### 定制\n\n- System Preferences -> Keyboard : 配置快捷键、菜单快捷键、modifier keys\n- [Karabiner](https://pqrs.org/osx/karabiner/index.html.en)\n- [Keyboard Maestro 介绍](http://www.waerfa.com/keyboard-maestro)\n- 定制建议\n\t- 原生为主，定制为辅\n\t- fix 原生不爽、有冲突的个别快捷键\n        - 合理使用 opt， 规避冲突\n\t- 根据自己习惯定制\n\t- 常反思，记不住的快捷键都是『对你不重要』的快捷键\n\n#### VIM - 潘君\n\n#####vim起源\n- 源自开源vi\n- 作者Bram Moolenaar\n- 80年代末,Amiga计算机中无vi,作者自行开发\n- Vi IMitation(模拟) -> Vi IMproved(改良)\n\n#####vim应用场景\n\t\n- linux\n- 平时代码\n\t\n#####vim模式\n列举常用模式如下\n需要了解所有模式\n在vim中使用`:help vim-modes`\n\n- Insert模式\n\t- 进入\n\t\t- i -> 在光标前插入\n\t\t- I-> 在句首插入\n\t\t- a -> 在光标后插入\n\t\t- A -> 在句尾插入\n\t- 离开\n\t\t- Esc\n\t\t- Ctrl + c\n\t\t- Ctrl + [\t\n\t\n- Normal模式\n\t- 进入vim的默认模式\n\t- 命令的天下\n\t\t- 简单移动\n\t\t\t- h j k l  -> 左 下 上 右\n\t\t\t- 0 (数字零) -> 移动光标到行头\n\t\t\t- $ -> 移动光标到行尾\n\t\t\t- gg -> 到第一行\n\t\t\t- G -> 到最后一行\n\t\t\t- w -> 到下一个单词的开头。\n\t\t\t- e -> 到下一个单词的结尾。\n\t\t- 简单操作 \n\t\t\t- dd -> 剪切当前行\n\t\t\t- yy ->  赋值当前行\n\t\t\t- p -> 粘贴\n\t\t\t- u -> 撤销\n\t- 神奇的`.`\n\t\t- 上次命令的重复\n\t\n\t- 命令的组合\n\t\t- daw -> 删除当前单词\n\t\t- 2dd -> 删除2行\n\t\t- 3p → 粘贴文本3次\n\t\t- 100idesu [ESC] → 会写下 “desu “100次\n\t\t- 0y$ -> 从行头拷贝到本行最后一个字符\n\n- visual模式\n\t- 进入\n\t\t- v\n\t\t- V\n\t\t- Ctrl + v\n\t- 退出\n\t\t- Esc\n\t\t- Ctrl + c\n\n- select模式\n\t- 进入\n\t\t- gh\n\t\t- gH\n\t\t- g(Ctrl + h)\n\n\t- 切换\n\t\t- Ctrl + o ->临时切换到可视化模式执行一个命令\n\t\t- Ctrl + g ->切换到可视化模式\n\n#####vim大冒险游戏\n- [游戏链接](http://vim-adventures.com/)\n\n#### VIM常用命令 - 王胜\n##### 光标移动\n- fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。\n- tx：和上面的命令类似，但是是移动到 x 的左边一个位置。\n- Fx：和 fx 类似，不过是往回找。\n- w：光标往前移动一个词。\n- b：光标往后移动一个词。\n- 0：移动光标到当前行首。\n- ^：移动光标到当前行的第一个字母位置。\n- $：移动光标到行尾。\n- )：移动光标到下一个句子。\n- ( ：移动光标到上一个句子\n\n##### 替换\n- :s/hello/world 替换当前行中第一个hello为world\n- :%s/hello/world 替换每一行中第一个hello为world\n- :s/hello/world/g 替换当前行中所有的hello为world\n- :%s/hello/world/g 替换每一行中所有的hello为world\n- :%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换\n\n##### 内容提取\n- :r !date 将当前时间插入到当前文件\n- :r /path/to/src.file 将src.file里的内容输出到当前文件\n\n##### 总结\nVIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。\n\n#### Xcode插件管理 - 张超耀\n - 古人云“工欲善其事,必先利其器”，打造一个强大的开发环境，是立即提升自身战斗力的绝佳途径！以下是常用的一些有力的XCode插件。\n \n - 插件管理器：[Alcatraz](http://alcatraz.io/) - The package manager for Xcode。\n\n - [ColorSense](https://github.com/omz/ColorSense-for-Xcode)XCode颜色显示插件\n \t- 代码里的那些冷冰冰的颜色数值，到底时什么颜色？如果你经常遇到这个问题，每每不得不运行下模拟器去看看，那么这个插件绝对不容错过。更彪悍的是你甚至可以点击显示的颜色面板，直接通过系统的ColorPicker来自动生成对应颜色代码，再也不用做各种颜色代码转换了！\n \t\n- [VVDocumenter](https://github.com/onevcat/VVDocumenter-Xcode)规范注释生成器\n\t- 很多时候，为了快速开发，很多的技术文档都是能省则省，这个时候注释就变得异常重要，再配合Doxygen这种注释自动生成文档的，就完美了。但是每次都要手动输入规范化的注释，着实也麻烦，但有了VVDocumenter，规范化的注释，主需要输入三个斜线“///”，就OK啦！\n\t\n- [XAlign](https://github.com/qfish/XAlign)代码整理\n\t- XAlign是一款专门用于代码整理的Xcode插件，其作者为来自Geek Zoo Studio的开发者QFish。XAlign能够对开发者的代码非常快速地进行对齐优化，有“=”、宏定义、属性三种对齐模式。当然，如果默认的对齐风格不是自己喜欢的，开发者还可以自定义或提出issues。 \n\n- [FuzzyAutocompletePlugin](https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin)代码自动补全插件\n\t- 通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。\n\t\n- XcodeBoost\n\t- XcodeBoost是一款可以让开发者轻而易举地检查和修改Objective-C代码的插件。XcodeBoost能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。\n\n\n##### [盘点开发者最喜爱的十大开源Xcode插件](http://www.csdn.net/article/2014-05-04/2819586-the-best-xcode-plugins/1)\n##### [那些不能错过的Xcode插件](http://www.cocoachina.com/industry/20130918/7022.html)\n\n","source":"_posts/2015.06.19 - 代码效率提升.md","raw":"title: 代码开发效率提升方法\ndate: 2015-06-19 23:04:29\ntags: \n- 开发效率\n- 效率\n\n---\n\n## 2015.06.19 - 技术分享，主题\"代码开发效率提升方法\"\n#### snippet的制作与使用 - 杨志平\n\n#####备份路径\n> ~/Library/Developer/Xcode/UserData/CodeSnippets/\n\n#####界面\n![image](http://static.oschina.net/uploads/space/2014/0306/145357_xj9O_868062.png)\n\n#####使用\n\n###### 1.系统自带\n\n很多我们的代码提示都是snippet系统已经有的代码块如：\nblock变量定义\n\n> typedef <#returnType#>(^<#name#>)(<#arguments#>);\n\n###### 2.常用变量\n- strong\n- weak\n- assign\n- block\n\n###### 3.常用方法\n- 比如：hiddenKeyBoard\n- 网络请求：getData\n- 上下拉刷新，等等\n\n###### 4.常用模块\n- 常用的代理协议方法集\n\n\n\n#####制作\n选中代码块拖入snippet library即可。为了方便调用可简单编辑\n\n![image2](http://static.oschina.net/uploads/space/2014/0306/143716_p6Kl_868062.png)\n\n#####PaintCode的简单使用\n\n简单的图形绘制，可像xib一样拖拽图形，并添加到view的CALayer层上\n\n- drawRect方法\n\n#### myEclipse分享 - 吴明\n - myEclipse主要WebService开发工具\n \n - MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。\n\n - [myEclipse使用ssh框架](http://www.cnblogs.com/younes/archive/2011/12/21/2295759.html)\n \t\n - myEclipse常用快捷键\n \t- Alt+Shift+s:\n \t\t打开myEclipse快捷键菜单\n\t\t- 自动生成get set方法\n\t\t- 自动生成无参和有参构造方法\n \t- Ctrl+D：删除当前行 \n \t- Ctrl+Alt+↓：复制当前行到下一行(复制增加)\n \t- Ctrl+Alt+↑：复制当前行到上一行(复制增加)\n \t- Alt+↓：当前行和下面一行交互位置\n \t- Alt+↑：当前行和上面一行交互位置\n \t- Ctrl+Shift+O：快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类\n - [ssh框架](http://baike.baidu.com/link?url=-FpesVZmaLqL3GJTVfPriU4jZQlvjIWKgbmy1lxgSlzT83WVAbFUA952pclZJbIkqzDTWVc7L-dTBalJjXTNH_)\n\n#### OSX 快捷键入门 - 曾铭\n\n##### OSX 系统级的快捷键支持\n\n- 统一标准的全局快捷键：如 FX、『设置』、opt\n\t- [一些『奇怪的』符号](https://support.apple.com/kb/PH18802?locale=zh_CN&viewlocale=zh_CN)\n\t- [Mac 键盘快捷键](https://support.apple.com/zh-cn/HT201236)\n\t- 有时，略略隐晦了些：如截图、奇葩的 cmd+tab,opt\n- 在统一之外，留意每个应用的快捷键：如 chrome：opt+cmd+i，cmd+l\n\t\n##### 讨论常用快捷键 （具体快捷键请自己查）\n\n- 设置\n- 剪切复制粘贴全选\n- 新建、新建 tab、切换 tab、关闭 tab、关闭应用\n- 光标的自由游走\n    - 上下左右（推荐 hjkl）、字符移动、行首行尾、文首文尾、向后删除、单词删除、行向前向后删除\n- Xcode\n\t- 上下移行 （@志平 推荐）\n\t- reveal to project navigator、切换 .h.m 文件\n\t- 显示隐藏 navigatiors、Debug area、Utilities\n\t- new tab、切换 tab、分割窗口\n\n##### 定制\n\n- System Preferences -> Keyboard : 配置快捷键、菜单快捷键、modifier keys\n- [Karabiner](https://pqrs.org/osx/karabiner/index.html.en)\n- [Keyboard Maestro 介绍](http://www.waerfa.com/keyboard-maestro)\n- 定制建议\n\t- 原生为主，定制为辅\n\t- fix 原生不爽、有冲突的个别快捷键\n        - 合理使用 opt， 规避冲突\n\t- 根据自己习惯定制\n\t- 常反思，记不住的快捷键都是『对你不重要』的快捷键\n\n#### VIM - 潘君\n\n#####vim起源\n- 源自开源vi\n- 作者Bram Moolenaar\n- 80年代末,Amiga计算机中无vi,作者自行开发\n- Vi IMitation(模拟) -> Vi IMproved(改良)\n\n#####vim应用场景\n\t\n- linux\n- 平时代码\n\t\n#####vim模式\n列举常用模式如下\n需要了解所有模式\n在vim中使用`:help vim-modes`\n\n- Insert模式\n\t- 进入\n\t\t- i -> 在光标前插入\n\t\t- I-> 在句首插入\n\t\t- a -> 在光标后插入\n\t\t- A -> 在句尾插入\n\t- 离开\n\t\t- Esc\n\t\t- Ctrl + c\n\t\t- Ctrl + [\t\n\t\n- Normal模式\n\t- 进入vim的默认模式\n\t- 命令的天下\n\t\t- 简单移动\n\t\t\t- h j k l  -> 左 下 上 右\n\t\t\t- 0 (数字零) -> 移动光标到行头\n\t\t\t- $ -> 移动光标到行尾\n\t\t\t- gg -> 到第一行\n\t\t\t- G -> 到最后一行\n\t\t\t- w -> 到下一个单词的开头。\n\t\t\t- e -> 到下一个单词的结尾。\n\t\t- 简单操作 \n\t\t\t- dd -> 剪切当前行\n\t\t\t- yy ->  赋值当前行\n\t\t\t- p -> 粘贴\n\t\t\t- u -> 撤销\n\t- 神奇的`.`\n\t\t- 上次命令的重复\n\t\n\t- 命令的组合\n\t\t- daw -> 删除当前单词\n\t\t- 2dd -> 删除2行\n\t\t- 3p → 粘贴文本3次\n\t\t- 100idesu [ESC] → 会写下 “desu “100次\n\t\t- 0y$ -> 从行头拷贝到本行最后一个字符\n\n- visual模式\n\t- 进入\n\t\t- v\n\t\t- V\n\t\t- Ctrl + v\n\t- 退出\n\t\t- Esc\n\t\t- Ctrl + c\n\n- select模式\n\t- 进入\n\t\t- gh\n\t\t- gH\n\t\t- g(Ctrl + h)\n\n\t- 切换\n\t\t- Ctrl + o ->临时切换到可视化模式执行一个命令\n\t\t- Ctrl + g ->切换到可视化模式\n\n#####vim大冒险游戏\n- [游戏链接](http://vim-adventures.com/)\n\n#### VIM常用命令 - 王胜\n##### 光标移动\n- fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。\n- tx：和上面的命令类似，但是是移动到 x 的左边一个位置。\n- Fx：和 fx 类似，不过是往回找。\n- w：光标往前移动一个词。\n- b：光标往后移动一个词。\n- 0：移动光标到当前行首。\n- ^：移动光标到当前行的第一个字母位置。\n- $：移动光标到行尾。\n- )：移动光标到下一个句子。\n- ( ：移动光标到上一个句子\n\n##### 替换\n- :s/hello/world 替换当前行中第一个hello为world\n- :%s/hello/world 替换每一行中第一个hello为world\n- :s/hello/world/g 替换当前行中所有的hello为world\n- :%s/hello/world/g 替换每一行中所有的hello为world\n- :%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换\n\n##### 内容提取\n- :r !date 将当前时间插入到当前文件\n- :r /path/to/src.file 将src.file里的内容输出到当前文件\n\n##### 总结\nVIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。\n\n#### Xcode插件管理 - 张超耀\n - 古人云“工欲善其事,必先利其器”，打造一个强大的开发环境，是立即提升自身战斗力的绝佳途径！以下是常用的一些有力的XCode插件。\n \n - 插件管理器：[Alcatraz](http://alcatraz.io/) - The package manager for Xcode。\n\n - [ColorSense](https://github.com/omz/ColorSense-for-Xcode)XCode颜色显示插件\n \t- 代码里的那些冷冰冰的颜色数值，到底时什么颜色？如果你经常遇到这个问题，每每不得不运行下模拟器去看看，那么这个插件绝对不容错过。更彪悍的是你甚至可以点击显示的颜色面板，直接通过系统的ColorPicker来自动生成对应颜色代码，再也不用做各种颜色代码转换了！\n \t\n- [VVDocumenter](https://github.com/onevcat/VVDocumenter-Xcode)规范注释生成器\n\t- 很多时候，为了快速开发，很多的技术文档都是能省则省，这个时候注释就变得异常重要，再配合Doxygen这种注释自动生成文档的，就完美了。但是每次都要手动输入规范化的注释，着实也麻烦，但有了VVDocumenter，规范化的注释，主需要输入三个斜线“///”，就OK啦！\n\t\n- [XAlign](https://github.com/qfish/XAlign)代码整理\n\t- XAlign是一款专门用于代码整理的Xcode插件，其作者为来自Geek Zoo Studio的开发者QFish。XAlign能够对开发者的代码非常快速地进行对齐优化，有“=”、宏定义、属性三种对齐模式。当然，如果默认的对齐风格不是自己喜欢的，开发者还可以自定义或提出issues。 \n\n- [FuzzyAutocompletePlugin](https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin)代码自动补全插件\n\t- 通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。\n\t\n- XcodeBoost\n\t- XcodeBoost是一款可以让开发者轻而易举地检查和修改Objective-C代码的插件。XcodeBoost能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。\n\n\n##### [盘点开发者最喜爱的十大开源Xcode插件](http://www.csdn.net/article/2014-05-04/2819586-the-best-xcode-plugins/1)\n##### [那些不能错过的Xcode插件](http://www.cocoachina.com/industry/20130918/7022.html)\n\n","slug":"2015.06.19 - 代码效率提升","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dy70008tfptfrlckqx3"},{"title":"开源","date":"2015-06-12T23:04:29.000Z","_content":"\n#### 开源利弊浅谈 - 张超耀\n#### 开源？\n- 开源，（Open Source）全称为开放源代码。开源就是要用户利用源代码在其基础上修改和学习的。\n\n####  优势何在？\n- 优势1：花费很少（如果有的话），许可费用\n\t- 当然，这往往省去那些讨厌的维护费用。\n- 优势2：易于管理\n\t- 只要你想，你可以在尽可能多的地方安装开源软件。无需为许可证合规性计数、跟踪或监视。\n- 优势3 ：连续，实时改进\n\t- 因为每个人都可以访问源码，任何人都可以主动修改BUG，使其变得更好，而不必等待下一个版本。\n- 优势4：公司独立\n\t- 如果创建该软件的公司挂掉，代码仍然可以通过其用户社区继续存在和发展。\n- 优势5 ：实践的探索\n\t- 我们可以很容易地“亲身探索”源码，以便更好地了解产品并作出改善。\n\n#### 劣势显著\n\n- 缺点1 ：它不是完全免费\n\t- 开源软件可以涉及意料之外的实施、管理和支持成本。\n- 缺点2：学习曲线（技术支持）\n\t- 你可能在开源的产品上需要聘请专家，让自己加快速度。\n- 缺点3：迷茫的用户\n\t- 由于并行发展的努力在进行中，用户可能不知道哪个版本做什么或是否与你专有平台上的其他软件兼容。\n- 缺点4：孤立软件\n\t- 由于关键的程序员的斗争和退出，或他们失去兴趣转移到新的项目，使一些开源项目陷于停顿和死亡。\n- 缺点5：独立地（凭自己的力量）\n \t- 与商业产品不同，没有人在开源社区义务来帮助你，或回答你的任何问题。\n\n#### 开源，仁者见仁智者见智\n\n\n#### 与开源有关的小故事 - 曾铭\n\n- 比尔·盖茨\n\t- 软件私有，保护版权\n\t- 1976 年 《致计算机爱好者的公开信》\n- 理查德.斯托曼\n\t- Free Soft\t\n\t- GNU，GPL，Emacs，GCC\n\t- 推荐两本书：《大教堂与集市》《Just for Fun》\n\t- [HHKB](https://www.v2ex.com/t/45480) ；）\n- 思考\n\t- 开源软件和私有软件哪个质量更高？\n\t- 怎样参与开源？：\n\t\t- Github\n\t\t- 开源就是一种开放交流的态度\n\t\t- 不怕暴露自己的傻 X，（每个人都认为自己是对的，）万一对了呢 ；）\n- 最后再推荐一部纪录片：[互联网之子](http://v.youku.com/v_show/id_XNzYyMDg3MzYw.html)\n\n#### 我如何接触开源 - 潘君\n\n- github trending\n\t- 代码 trending\n\t\t- 寻找有潜力的开源项目\n\t- 开发者 trending\n\t\t- 好的开发者应该不止一个好软件 顺藤摸瓜比较方便\n\n- 苹果官方开源\n\t- [Apple Open Source](http://www.opensource.apple.com/)\n\t- 重点代码\n\t\t- [runtime](http://www.opensource.apple.com/source/objc4/objc4-437.1/runtime/)\n\n- 开源软件闲暇阅读工具\n\t- CodeNav - 移动端优秀的代码查看软件\n\t\t- 优点\n\t\t\t- 支持多种方式导入源码\n\t\t\t- 交互不错 各种操作都算是方便\n\t\t- 缺点\n\t\t\t- 大屏支持还有bug\n\t\t\t- 不支持swift语法高亮\n\n\t\n\n- 自用较多的开源软件\n\t- [WWDC app for OS X](https://github.com/insidegui/WWDC)\n\t- [eggscellent](https://github.com/monoclesociety/eggscellent)\n\t- [calibre](https://github.com/kovidgoyal/calibre)\n\t\n\n#### 参与开源软件的心得 - 王胜\n  - 参与方式：\n    - 泡开源官方网站论坛，并参与issue讨论\n    - 修改源码，生成patch文件，发给社区维护者\n    - 有了Git && Github后，可以fork分支，修改代码，发送pull request\n  - 参与过程情绪波动：\n    查看源码 -> 领悟学习 -> 发现问题 -> 动手解决 -> 跟社区提交者沟通纳入源码树 or 通过github发送pull request\n    -> 上游采用 -> 成就感十足。从而形成良性持续性参与感，并参与其中。\n  - 收获心得：\n    - 一次提交只做一件事\n    - 提交说明规范、简单、见名知意。后续参与者看提交树就能看到软件的演化历史\n    - 代码开源，足够多的眼睛，使bug无处可藏\n    - 开源导致世界范围内可见，代码的创意来自于全球智慧的汇聚\n\n#### OkHttp开源框架介绍 - 李仙鹏\n##### SPDY\n\nGoogle开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。\n> 新协议的功能:\n> \n> * 数据流的多路复用\n> * 请求优先级\n> * HTTP报头压缩。\n> * 服务器推送（即Server Push技术）\n\n谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64%。\n\n现在已经被Google弃用，推出新的基于SPDY实现的HTTP2.0。\n\n##### HTTP2.0\n\nHTTP也是基于TCP的应用层协议，大家熟知的为：\n\n* HTTP 0.9，只有基本的文本 GET 功能。\n* HTTP 1.0，完善的请求/响应模型，并将协议补充完整。\n* HTTP 1.1，在 1.0 基础上进行更新，增加了如 长久连接 keep-alive 与 chunked 等功能。\n\nHTTP 2.0在2013年8月推出，基于Google的SPDY开发。\n\n##### OkHTTP\n\n[OKHTTP](http://square.github.io/okhttp/)is an HTTP client that’s efficient by default:\n\n* HTTP/2 and SPDY support allows all requests to the same host to share a socket.\n* Connection pooling reduces request latency (if SPDY isn’t available).\n* Transparent GZIP shrinks download sizes.\n* Response caching avoids the network completely for repeat requests.\n\n> OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.\n> You'll also need Okio, which OkHttp uses for fast I/O and resizable buffers.\n\n\n#### 如何推广自己的开源项目(github获取更多的star) - 杨志平\n\n#####前言\n`你可能花费几天甚至几个月时间开源一个你写的代码，但是没有人去使用它，靠运气的话可能可以推广.\n现在我讲讲如何让人们关注我们的作品。该要点是打破下面的图片的循环`\n\n![图片一](https://d262ilb51hltx0.cloudfront.net/max/727/1*xBernzyrTjSbfMMQWdE0qQ.png)\n\n####六步（4-6是秘诀）\n1. Projects are Everything\n- Read and Research\n- Building the Repo\n- README 文件\n- 图解\n- 更新反馈\n\n####1.Projects are Everything\n开源代码就是给其他程序员解决问题或者节约时间的\n\n####2.Read and Research\n`很多问题都已经解决成千上万次了`\n你可以想一个你感兴趣的开源项目，上网搜索确认它的实现是不是已经有很多人实现了并有很多人已经使用它了，那就忘了这个想法。但是如果没有，或者解决方案不理想（可以通过issues查看他们的不足）你有时间的话就建一个和他们相识的开源项目，修复一些issues使用自己的文档（感觉有点无耻，但听说很有效）\n\n###3.Building the Repo\n有一点就是，通常我们后面的repo的star增加速度比以前的repo要快挺多的，可能是以前的repo使得更多人认识你相信你。\n\n####4.README 文件(推荐布局方案)\n\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/861/1*JK3G5F-iIO7JFwxN9Dnwrw.png)\n\n####5.图解（特效，一目了然）\n\n![Flipboard playing multiple GIFs](https://github.com/ZhipingYang/UUChatTableView/raw/master/Demo/UUChatTableViewTests/ChatTableView.gif)\n\n####6.更新反馈\n完成以上步骤，并不断更新开源库及时解决issues里面的bug就很有希望进入\nstar趋势\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/1800/1*Yk2DM31wlKquLH7CIN5vkQ.png)\n贡献名人\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/948/1*QFeal7p7uUS0As74S1tePA.png)\n\n\n#### 开源协议 - 吴明\n  - 无规矩不成方圆，开源协议\n \n \t- BSD开源协议：满足三个条件\n \t\t- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议\n \t\t- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议\n \t\t- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广\n\t- Apache Licence 2.0：(关心软件的专利问题，但同样希望宽松，选择这个协议)\n\t   - 需要给代码的用户一份Apache Licence\n\t   - 如果你修改了代码，需要再被修改的文件中说明。\n\t   - 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明\n\t   - 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改\n\t \n\t- GPL：(Linux)(希望代码使用者同样能把他们的贡献分享出来，那就选择GPL)\n\t\t- GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样\n\t\t- 代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售\n\t\t- 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。\n\n\t- MIT：(简单、宽松，\"为所欲为\",选择这个协议)\n\t\t- 类似BSD协议\n\t- Mozilla\n\t\n\t- LGPL\n\t  - LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。\n\t\t\n\t- 说了这么多最后一个[开源协议的选择](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\t- 其他\n\t\t- [github开源协议选择](http://choosealicense.com/)\n\t\t- [参考1](http://www.awflasher.com/blog/archives/939)\n\t\t- [参考2](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\t\n\n\n","source":"_posts/2015.06.12 - 开源.md","raw":"title: 开源\ndate: 2015-06-12 23:04:29\ntags:\n---\n\n#### 开源利弊浅谈 - 张超耀\n#### 开源？\n- 开源，（Open Source）全称为开放源代码。开源就是要用户利用源代码在其基础上修改和学习的。\n\n####  优势何在？\n- 优势1：花费很少（如果有的话），许可费用\n\t- 当然，这往往省去那些讨厌的维护费用。\n- 优势2：易于管理\n\t- 只要你想，你可以在尽可能多的地方安装开源软件。无需为许可证合规性计数、跟踪或监视。\n- 优势3 ：连续，实时改进\n\t- 因为每个人都可以访问源码，任何人都可以主动修改BUG，使其变得更好，而不必等待下一个版本。\n- 优势4：公司独立\n\t- 如果创建该软件的公司挂掉，代码仍然可以通过其用户社区继续存在和发展。\n- 优势5 ：实践的探索\n\t- 我们可以很容易地“亲身探索”源码，以便更好地了解产品并作出改善。\n\n#### 劣势显著\n\n- 缺点1 ：它不是完全免费\n\t- 开源软件可以涉及意料之外的实施、管理和支持成本。\n- 缺点2：学习曲线（技术支持）\n\t- 你可能在开源的产品上需要聘请专家，让自己加快速度。\n- 缺点3：迷茫的用户\n\t- 由于并行发展的努力在进行中，用户可能不知道哪个版本做什么或是否与你专有平台上的其他软件兼容。\n- 缺点4：孤立软件\n\t- 由于关键的程序员的斗争和退出，或他们失去兴趣转移到新的项目，使一些开源项目陷于停顿和死亡。\n- 缺点5：独立地（凭自己的力量）\n \t- 与商业产品不同，没有人在开源社区义务来帮助你，或回答你的任何问题。\n\n#### 开源，仁者见仁智者见智\n\n\n#### 与开源有关的小故事 - 曾铭\n\n- 比尔·盖茨\n\t- 软件私有，保护版权\n\t- 1976 年 《致计算机爱好者的公开信》\n- 理查德.斯托曼\n\t- Free Soft\t\n\t- GNU，GPL，Emacs，GCC\n\t- 推荐两本书：《大教堂与集市》《Just for Fun》\n\t- [HHKB](https://www.v2ex.com/t/45480) ；）\n- 思考\n\t- 开源软件和私有软件哪个质量更高？\n\t- 怎样参与开源？：\n\t\t- Github\n\t\t- 开源就是一种开放交流的态度\n\t\t- 不怕暴露自己的傻 X，（每个人都认为自己是对的，）万一对了呢 ；）\n- 最后再推荐一部纪录片：[互联网之子](http://v.youku.com/v_show/id_XNzYyMDg3MzYw.html)\n\n#### 我如何接触开源 - 潘君\n\n- github trending\n\t- 代码 trending\n\t\t- 寻找有潜力的开源项目\n\t- 开发者 trending\n\t\t- 好的开发者应该不止一个好软件 顺藤摸瓜比较方便\n\n- 苹果官方开源\n\t- [Apple Open Source](http://www.opensource.apple.com/)\n\t- 重点代码\n\t\t- [runtime](http://www.opensource.apple.com/source/objc4/objc4-437.1/runtime/)\n\n- 开源软件闲暇阅读工具\n\t- CodeNav - 移动端优秀的代码查看软件\n\t\t- 优点\n\t\t\t- 支持多种方式导入源码\n\t\t\t- 交互不错 各种操作都算是方便\n\t\t- 缺点\n\t\t\t- 大屏支持还有bug\n\t\t\t- 不支持swift语法高亮\n\n\t\n\n- 自用较多的开源软件\n\t- [WWDC app for OS X](https://github.com/insidegui/WWDC)\n\t- [eggscellent](https://github.com/monoclesociety/eggscellent)\n\t- [calibre](https://github.com/kovidgoyal/calibre)\n\t\n\n#### 参与开源软件的心得 - 王胜\n  - 参与方式：\n    - 泡开源官方网站论坛，并参与issue讨论\n    - 修改源码，生成patch文件，发给社区维护者\n    - 有了Git && Github后，可以fork分支，修改代码，发送pull request\n  - 参与过程情绪波动：\n    查看源码 -> 领悟学习 -> 发现问题 -> 动手解决 -> 跟社区提交者沟通纳入源码树 or 通过github发送pull request\n    -> 上游采用 -> 成就感十足。从而形成良性持续性参与感，并参与其中。\n  - 收获心得：\n    - 一次提交只做一件事\n    - 提交说明规范、简单、见名知意。后续参与者看提交树就能看到软件的演化历史\n    - 代码开源，足够多的眼睛，使bug无处可藏\n    - 开源导致世界范围内可见，代码的创意来自于全球智慧的汇聚\n\n#### OkHttp开源框架介绍 - 李仙鹏\n##### SPDY\n\nGoogle开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。\n> 新协议的功能:\n> \n> * 数据流的多路复用\n> * 请求优先级\n> * HTTP报头压缩。\n> * 服务器推送（即Server Push技术）\n\n谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64%。\n\n现在已经被Google弃用，推出新的基于SPDY实现的HTTP2.0。\n\n##### HTTP2.0\n\nHTTP也是基于TCP的应用层协议，大家熟知的为：\n\n* HTTP 0.9，只有基本的文本 GET 功能。\n* HTTP 1.0，完善的请求/响应模型，并将协议补充完整。\n* HTTP 1.1，在 1.0 基础上进行更新，增加了如 长久连接 keep-alive 与 chunked 等功能。\n\nHTTP 2.0在2013年8月推出，基于Google的SPDY开发。\n\n##### OkHTTP\n\n[OKHTTP](http://square.github.io/okhttp/)is an HTTP client that’s efficient by default:\n\n* HTTP/2 and SPDY support allows all requests to the same host to share a socket.\n* Connection pooling reduces request latency (if SPDY isn’t available).\n* Transparent GZIP shrinks download sizes.\n* Response caching avoids the network completely for repeat requests.\n\n> OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.\n> You'll also need Okio, which OkHttp uses for fast I/O and resizable buffers.\n\n\n#### 如何推广自己的开源项目(github获取更多的star) - 杨志平\n\n#####前言\n`你可能花费几天甚至几个月时间开源一个你写的代码，但是没有人去使用它，靠运气的话可能可以推广.\n现在我讲讲如何让人们关注我们的作品。该要点是打破下面的图片的循环`\n\n![图片一](https://d262ilb51hltx0.cloudfront.net/max/727/1*xBernzyrTjSbfMMQWdE0qQ.png)\n\n####六步（4-6是秘诀）\n1. Projects are Everything\n- Read and Research\n- Building the Repo\n- README 文件\n- 图解\n- 更新反馈\n\n####1.Projects are Everything\n开源代码就是给其他程序员解决问题或者节约时间的\n\n####2.Read and Research\n`很多问题都已经解决成千上万次了`\n你可以想一个你感兴趣的开源项目，上网搜索确认它的实现是不是已经有很多人实现了并有很多人已经使用它了，那就忘了这个想法。但是如果没有，或者解决方案不理想（可以通过issues查看他们的不足）你有时间的话就建一个和他们相识的开源项目，修复一些issues使用自己的文档（感觉有点无耻，但听说很有效）\n\n###3.Building the Repo\n有一点就是，通常我们后面的repo的star增加速度比以前的repo要快挺多的，可能是以前的repo使得更多人认识你相信你。\n\n####4.README 文件(推荐布局方案)\n\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/861/1*JK3G5F-iIO7JFwxN9Dnwrw.png)\n\n####5.图解（特效，一目了然）\n\n![Flipboard playing multiple GIFs](https://github.com/ZhipingYang/UUChatTableView/raw/master/Demo/UUChatTableViewTests/ChatTableView.gif)\n\n####6.更新反馈\n完成以上步骤，并不断更新开源库及时解决issues里面的bug就很有希望进入\nstar趋势\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/1800/1*Yk2DM31wlKquLH7CIN5vkQ.png)\n贡献名人\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/948/1*QFeal7p7uUS0As74S1tePA.png)\n\n\n#### 开源协议 - 吴明\n  - 无规矩不成方圆，开源协议\n \n \t- BSD开源协议：满足三个条件\n \t\t- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议\n \t\t- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议\n \t\t- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广\n\t- Apache Licence 2.0：(关心软件的专利问题，但同样希望宽松，选择这个协议)\n\t   - 需要给代码的用户一份Apache Licence\n\t   - 如果你修改了代码，需要再被修改的文件中说明。\n\t   - 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明\n\t   - 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改\n\t \n\t- GPL：(Linux)(希望代码使用者同样能把他们的贡献分享出来，那就选择GPL)\n\t\t- GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样\n\t\t- 代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售\n\t\t- 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。\n\n\t- MIT：(简单、宽松，\"为所欲为\",选择这个协议)\n\t\t- 类似BSD协议\n\t- Mozilla\n\t\n\t- LGPL\n\t  - LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。\n\t\t\n\t- 说了这么多最后一个[开源协议的选择](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\t- 其他\n\t\t- [github开源协议选择](http://choosealicense.com/)\n\t\t- [参考1](http://www.awflasher.com/blog/archives/939)\n\t\t- [参考2](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\t\n\n\n","slug":"2015.06.12 - 开源","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dy9000dtfptaba0vtuv"},{"title":"博客分享主题","date":"2015-06-05T23:04:29.000Z","_content":"\n## 2015.06.05 - 博客分享主题\n\n### android学习网站 - 王胜\n\n- [Android官网](http://developer.android.com/index.html)\n  - 官方SDK\n  - 官方API文档\n  - 官方training教程\n  - 官方Sample【1.x之后的Android Studio有直接导入Sample的功能】\n- [任玉刚博客](http://blog.csdn.net/singwhatiwanna/)\n  专注Android底层实现机制解析\n\n####android博客与学习网站 - 李仙鹏\n\n- [Android官方开发博客](http://android-developers.blogspot.hk)，并非[Android开发者官网](http://developer.android.com/index.html)，官方会维护更新，非常适合Android开发者学习。\n- [Android Development G+](https://plus.google.com/communities/105153134372062985968)\n- [Romain Guy](http://www.curious-creature.com/category/android/)(google android工程师)\n- [Trinea](http://www.trinea.cn)\n- [android开源项目分析](http://www.codekk.com/open-source-project-analysis)\n\n####博客框架与网站&&博客推荐 - 杨志平\n##### 常见博客框架\n\n- [Ghost](https://ghost.org) 优美简易（收费）\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/TryGhost/Ghost)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=Ghost+theme&type=Repositories&ref=searchresults)\n\t- [主题 - 官方](http://marketplace.ghost.org/)\n\t\n\n- [Octopress](http://octopress.org) 免费，比较繁琐\n\n\t- 范例见 [唐巧博客](http://blog.devtang.com)\n\t- [开源代码](https://github.com/imathis/octopress)\n\t- [主题样式](https://github.com/search?utf8=%E2%9C%93&q=Octopress+theme&type=Repositories&ref=searchresults)\n\n- [Hexo](http://hexo.io) 没用过\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\t- [主题样式 - 官方](http://hexo.io/themes/)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\n##### 常见iOS开发博客网站\n\n- 国内\n\t- [onev](http://onevcat.com/)\n\t- [唐巧](http://blog.devtang.com/)\n\t- [limboy](http://limboy.me/)\n\t- [objc中国](http://objccn.io/)\n\t- [NSHipster中国](http://nshipster.cn/)\n\t- [玉令天下 ](http://yulingtianxia.com/)\n\t- [不会开机的男孩 ](http://studentdeng.github.io/blog/archives/)\n\t\n- 国外\n\t- [objc](http://www.objc.io/)\n\t- [MainiacDev](https://maniacdev.com/)\n\t- [Ray Wenderlich](http://www.raywenderlich.com/ios-tutorials)\n\t- [NSHipster](http://nshipster.com/)\n\n####  Android博客分享 - 吴明\n\n   - [代码家](http://blog.daimajia.com)\n\n       - 最新好玩的android效果\n       - 1到2周更新一次\n       - 提供源码\n       \n   - [郭霖博客](http://blog.csdn.net/guolin_blog/)\n       - 资深Android开发工程师、架构师\n       - 畅销技术书籍《第一行代码——Android》\n       - 博客主要针对android的最新技术分享透彻逻辑性强\n       \n   - [android性能优化](http://hukai.me/android-training-course-in-chinese/index.html)\n       - 学习Android应用开发的绝佳资料\n       - Google Android团队在2012年的时候开设了Android Training板块\n       \n   - [Android开发资源汇总](http://www.2cto.com/kf/201406/307331.html)\n\n####博客工具与博客推荐 - 潘君\n\n- 博客工具Feedly\n\t- 优点\n\t\t- 全平台\n\t\t- 可批量导入RSS订阅OPML文件([唐巧推荐博客OPML](https://raw.githubusercontent.com/tangqiaoboy/iOSBlogCN/master/blogcn.opml))\n\t\t- 内置搜索功能，根据关键词搜索感兴趣的博客\n\t\n- 博客推荐\n\t\n\t- [Limboy](http://limboy.me/)\n\t\t- 技术之余不乏鸡汤\n\t\t- 涉猎较广,不仅限iOS\n\t\t- iOS相关类较为深入,很有借鉴意义\n\t\t- 优秀重点博文推荐-[读 Facebook App 头文件的一些收获](http://limboy.me/ios/2014/11/28/facebook-app-headers.html)\n\t\t\t- 相关工具索引:[class-dump](http://stevenygard.com/projects/class-dump/)\n\t\t\t- 相关文章教程:[iOS 使用Class-dump分析App内部实现](http://itony.me/200.html)\n\t\n\t- [阮一峰的网络日志](http://www.ruanyifeng.com/blog/)\n\t\t- 内容都较为浅显易懂,比较适合开拓眼界\n\t\t- 内容都较为与时俱进,都是当前较为流行的一些主题\n\t\t- 优秀重点博文推荐-[React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)\n\n\n#### 聊聊静态博客平台 - 曾铭\n\n- WordPress\n- Blogger\n- Tumblr\n- Ghost (node.js) WordPress 替代\n\n##### 博客的需求：\n\n>\n- 写文章：（markdown，draft，category，tag）\n- 交流：评论、社区\n- 好看：theme（排版、中文排版、代码）\n- 好玩：自定义\n- 域名\n\n\n\n##### 静态博客\n\n>\n- 博客何必动态生成，静态页面即可\n- 评论用第三方：多说，Disqus\n\n- Jekyll （Github Pager）ruby\n- Octopress 基于 Jekyll\n- Hexo (node.js)\n\n##### 非静态\n\n>\n- 我只是想『漂亮』的写文章\n\n- Scriptogr.am\n\t- dropbox 同步\n\t- 自定义主题 \n- FarBox\n\t- dropbox 同步\n\t- 自定义主题\n\t- Mac 客户端\n- pancake.io\n- Medium\n\t- 有社区，大部分是设计师\n\t- 漂亮\n\t- 有 App\n\t- 不能导出 md\n- Logdown\n- [作业部落](https://www.zybuluo.com/mdeditor)\n- [简书](http://www.jianshu.com/)\n\n##### 大道无形\n\n>\n- 写 ： 无论静态博客多好玩，多写点文字才是最重要的\n- [为什么你应该（从现在开始就）写博客](http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/)\n\n\n\n#### 技术博客分享 - 张超耀\n- [objc中国](http://objccn.io)\n\t- [onevcat](http://onev.cat) 创建，文章源自[objc.io](http://www.objc.io)，由[objc中国项目组](https://github.com/objccn) 整理维护\n\t- 为中国 `Objective-C` 社区带来最佳实践和先进技术.\n\n\t\n- [唐巧的技术博客](http://www.devtang.com/blog/categories/ios/)(记录下自己学习的点滴)\n\t- 唐巧：猿题库iOS开发工程师，给InfoQ的「iOS 开发周报」供稿，并且转载到个人博客上。 \t\n\n- [ITeye](http://www.iteye.com)\n\t- [ITeye起源](http://baike.baidu.com/link?url=bKegOkXpVAHodrvY1dSVwb0m7w3lgHPS4sUfR6kFo27giN181V4BnRlpmHNR9fEbnuXa3BkINVZVMAWAPR94wK)：ITeye即创办于2003年9月的javaEye，缘起是创始人范凯自己在学习和研究java的开源框架却发现没有一个讨论的地方，于是自己就办一个。\n\t- 一个优秀的Java学习交流分享平台。\n\n","source":"_posts/2015.06.05 - 博客分享.md","raw":"title: 博客分享主题\ndate: 2015-06-05 23:04:29\ntags:\n- 博客\n- 网站\n\n---\n\n## 2015.06.05 - 博客分享主题\n\n### android学习网站 - 王胜\n\n- [Android官网](http://developer.android.com/index.html)\n  - 官方SDK\n  - 官方API文档\n  - 官方training教程\n  - 官方Sample【1.x之后的Android Studio有直接导入Sample的功能】\n- [任玉刚博客](http://blog.csdn.net/singwhatiwanna/)\n  专注Android底层实现机制解析\n\n####android博客与学习网站 - 李仙鹏\n\n- [Android官方开发博客](http://android-developers.blogspot.hk)，并非[Android开发者官网](http://developer.android.com/index.html)，官方会维护更新，非常适合Android开发者学习。\n- [Android Development G+](https://plus.google.com/communities/105153134372062985968)\n- [Romain Guy](http://www.curious-creature.com/category/android/)(google android工程师)\n- [Trinea](http://www.trinea.cn)\n- [android开源项目分析](http://www.codekk.com/open-source-project-analysis)\n\n####博客框架与网站&&博客推荐 - 杨志平\n##### 常见博客框架\n\n- [Ghost](https://ghost.org) 优美简易（收费）\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/TryGhost/Ghost)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=Ghost+theme&type=Repositories&ref=searchresults)\n\t- [主题 - 官方](http://marketplace.ghost.org/)\n\t\n\n- [Octopress](http://octopress.org) 免费，比较繁琐\n\n\t- 范例见 [唐巧博客](http://blog.devtang.com)\n\t- [开源代码](https://github.com/imathis/octopress)\n\t- [主题样式](https://github.com/search?utf8=%E2%9C%93&q=Octopress+theme&type=Repositories&ref=searchresults)\n\n- [Hexo](http://hexo.io) 没用过\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\t- [主题样式 - 官方](http://hexo.io/themes/)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\n##### 常见iOS开发博客网站\n\n- 国内\n\t- [onev](http://onevcat.com/)\n\t- [唐巧](http://blog.devtang.com/)\n\t- [limboy](http://limboy.me/)\n\t- [objc中国](http://objccn.io/)\n\t- [NSHipster中国](http://nshipster.cn/)\n\t- [玉令天下 ](http://yulingtianxia.com/)\n\t- [不会开机的男孩 ](http://studentdeng.github.io/blog/archives/)\n\t\n- 国外\n\t- [objc](http://www.objc.io/)\n\t- [MainiacDev](https://maniacdev.com/)\n\t- [Ray Wenderlich](http://www.raywenderlich.com/ios-tutorials)\n\t- [NSHipster](http://nshipster.com/)\n\n####  Android博客分享 - 吴明\n\n   - [代码家](http://blog.daimajia.com)\n\n       - 最新好玩的android效果\n       - 1到2周更新一次\n       - 提供源码\n       \n   - [郭霖博客](http://blog.csdn.net/guolin_blog/)\n       - 资深Android开发工程师、架构师\n       - 畅销技术书籍《第一行代码——Android》\n       - 博客主要针对android的最新技术分享透彻逻辑性强\n       \n   - [android性能优化](http://hukai.me/android-training-course-in-chinese/index.html)\n       - 学习Android应用开发的绝佳资料\n       - Google Android团队在2012年的时候开设了Android Training板块\n       \n   - [Android开发资源汇总](http://www.2cto.com/kf/201406/307331.html)\n\n####博客工具与博客推荐 - 潘君\n\n- 博客工具Feedly\n\t- 优点\n\t\t- 全平台\n\t\t- 可批量导入RSS订阅OPML文件([唐巧推荐博客OPML](https://raw.githubusercontent.com/tangqiaoboy/iOSBlogCN/master/blogcn.opml))\n\t\t- 内置搜索功能，根据关键词搜索感兴趣的博客\n\t\n- 博客推荐\n\t\n\t- [Limboy](http://limboy.me/)\n\t\t- 技术之余不乏鸡汤\n\t\t- 涉猎较广,不仅限iOS\n\t\t- iOS相关类较为深入,很有借鉴意义\n\t\t- 优秀重点博文推荐-[读 Facebook App 头文件的一些收获](http://limboy.me/ios/2014/11/28/facebook-app-headers.html)\n\t\t\t- 相关工具索引:[class-dump](http://stevenygard.com/projects/class-dump/)\n\t\t\t- 相关文章教程:[iOS 使用Class-dump分析App内部实现](http://itony.me/200.html)\n\t\n\t- [阮一峰的网络日志](http://www.ruanyifeng.com/blog/)\n\t\t- 内容都较为浅显易懂,比较适合开拓眼界\n\t\t- 内容都较为与时俱进,都是当前较为流行的一些主题\n\t\t- 优秀重点博文推荐-[React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)\n\n\n#### 聊聊静态博客平台 - 曾铭\n\n- WordPress\n- Blogger\n- Tumblr\n- Ghost (node.js) WordPress 替代\n\n##### 博客的需求：\n\n>\n- 写文章：（markdown，draft，category，tag）\n- 交流：评论、社区\n- 好看：theme（排版、中文排版、代码）\n- 好玩：自定义\n- 域名\n\n\n\n##### 静态博客\n\n>\n- 博客何必动态生成，静态页面即可\n- 评论用第三方：多说，Disqus\n\n- Jekyll （Github Pager）ruby\n- Octopress 基于 Jekyll\n- Hexo (node.js)\n\n##### 非静态\n\n>\n- 我只是想『漂亮』的写文章\n\n- Scriptogr.am\n\t- dropbox 同步\n\t- 自定义主题 \n- FarBox\n\t- dropbox 同步\n\t- 自定义主题\n\t- Mac 客户端\n- pancake.io\n- Medium\n\t- 有社区，大部分是设计师\n\t- 漂亮\n\t- 有 App\n\t- 不能导出 md\n- Logdown\n- [作业部落](https://www.zybuluo.com/mdeditor)\n- [简书](http://www.jianshu.com/)\n\n##### 大道无形\n\n>\n- 写 ： 无论静态博客多好玩，多写点文字才是最重要的\n- [为什么你应该（从现在开始就）写博客](http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/)\n\n\n\n#### 技术博客分享 - 张超耀\n- [objc中国](http://objccn.io)\n\t- [onevcat](http://onev.cat) 创建，文章源自[objc.io](http://www.objc.io)，由[objc中国项目组](https://github.com/objccn) 整理维护\n\t- 为中国 `Objective-C` 社区带来最佳实践和先进技术.\n\n\t\n- [唐巧的技术博客](http://www.devtang.com/blog/categories/ios/)(记录下自己学习的点滴)\n\t- 唐巧：猿题库iOS开发工程师，给InfoQ的「iOS 开发周报」供稿，并且转载到个人博客上。 \t\n\n- [ITeye](http://www.iteye.com)\n\t- [ITeye起源](http://baike.baidu.com/link?url=bKegOkXpVAHodrvY1dSVwb0m7w3lgHPS4sUfR6kFo27giN181V4BnRlpmHNR9fEbnuXa3BkINVZVMAWAPR94wK)：ITeye即创办于2003年9月的javaEye，缘起是创始人范凯自己在学习和研究java的开源框架却发现没有一个讨论的地方，于是自己就办一个。\n\t- 一个优秀的Java学习交流分享平台。\n\n","slug":"2015.06.05 - 博客分享","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dya000etfptyxl3hpc9"},{"title":"游戏开发","date":"2015-05-29T23:04:29.000Z","_content":"\n## 2015.05.29 - 游戏开发主题\n\n#### Unity集成开发工具简介 - 李仙鹏\n\n- Unity IDE界面介绍\n- Unity IDE扩展介绍\n\n\n#### run-zombie-run HTML5 游戏 - 曾铭\n\n- HTML5 网页游戏，僵尸围攻对战游戏。支持局域网两名玩家，一名用键盘已经用手机打开手柄网页体感控制。\n\t- 技术关键词: web-socket, HTML5 Canvas\n\t- 柏茲模型算法参考 - [混沌邊緣的藝術－人工生命](http://redbug0314.blogspot.com/2009/06/blog-post.html)\n- 移动开发前端开发不分家，推荐阅读：\n\t- [HTML5 设计原理](http://developer.51cto.com/art/201103/247880_all.htm) 极其经典的一篇文章，从根本上理解 HTML5 来龙去脉。网上竟然找不到原始链接，神奇！\n- [Open Source](https://github.com/mithvv/run-zombie-run)\n- 链接有干货 ；）\n\n\n\n####Cocos2d闲扯与手游推荐 - 潘君\n\n#####Cocos2d  \n\t\n- 最早版本为oc版本，为cocos2d-iphone，[源码地址](https://code.google.com/p/cocos2d-iphone/)  \n\t\n- 现在C++移植版本cocos2d-x为手游两大跨平台手游开发引擎之一（另外一个为Unity）,[下载地址](http://www.cocos2d-x.org/)\n\n- 现在cocos2d-x维护主要为中国团队,触动科技\n\n- cocos2d基于[OpenGL ES](https://www.khronos.org/opengles/),与苹果官方游戏开发引擎Sprite一致\n\n其他参考资料：    \n\n* [App Store中开源游戏汇总](http://www.cnblogs.com/lingzhao/p/4165335.html)\n* [泰然论坛](https://www.khronos.org/opengles/)\n* [cocochina cocos讨论区](http://www.cocoachina.com/bbs/thread.php?fid=48)\n\n\n#####小游戏推荐\n\n- [Shadowmatic](https://itunes.apple.com/us/app/shadowmatic/id775888026?mt=8)  \n\t益智类3D游戏，通过对物体投射在墙上的影子拼凑构成生活中某一样事物。\n\t\n- [FRAMED](https://itunes.apple.com/us/app/framed/id886565180?mt=8)\n\t拼图类过关游戏，你必须自己观察游戏中的拼图，只有完成正确的拼图，主人公才能通过关卡中敌人的拦截。\n\n\n#### 游戏的起源与发展 - 张超耀\n- [游戏的故事：揭秘电子游戏诞生史](http://www.tudou.com/programs/view/cqT8Z-nZvn8/?from=timeline&isappinstalled=0)\n\t- 穿越时空，拯救世界，成为英雄……这些飘渺无际的虚幻想法，在这个时代，终于可以在“电子游戏”的世界中得以实现。而当我们在享受这个人类智慧结晶给我们带来的奇妙体验之时，有没有想过，是谁创造了如此这种娱乐方式？电子游戏又是如何发展蜕变的？ \n- [游戏的故事：从“硅与神经键”到动视暴雪](http://www.tudou.com/programs/view/cpwCix2sI48/?from=timeline&isappinstalled=0)\n\t- 暴雪出品，必属精品。这句流传在玩家中的8个字，是人们对暴雪这家游戏公司的肯定和赞美。暴雪为何能成为全球谈论最多的游戏公司之一？它又是否实至名归？游久网游戏的故事带你揭秘——从“硅与神经键”到动视暴雪。\n\n#### 游戏（APP）开发学习网站小游戏分享 - 杨志平\n- [udemy 全功能在线教育网站](https://www.udemy.com)\n\n `udemy = you + academy`\n \n Udemy目前有超过500万名注册用户，和超过22000门课程。与其他在线教育平台不同的是，Udemy不仅开放各种课程，更开放了教学的机会\n\n- [Ray Wenderlich iOS开发的百科全书](http://www.raywenderlich.com)\n\n`包含最新的iOS技术、最新语言等教程`\n\n随便提一下程序员学习利器 [Codecademy](http://www.codecademy.com) 免费, 起码做的比MOOC好\n\n\n##### 小游戏分享\n- Flappy Bird - 已下架\n- [Mr Jump](https://itunes.apple.com/cn/app/mr-jump/id955157084?mt=8&ign-mpt=uo%3D4) - 推荐\n- [fight!](https://itunes.apple.com/th/app/angry-birds-fight!/id933958078?mt=8) - 愤怒的小鸟新品，存在不足\n\n\n#### 2015 Google I/O 大会 - 王胜\n北京时间5月29日00:30，谷歌在美国旧金山召开了一年一度的开发者大会，发布了Android M等新品。\n- Android M 预览版\nAndroid M此次没有大规模新的API发布，而是回到质量上，改善用户体验。具体变动如下：\n  - 应用程序权限控制\n    应用程序在使用功能时才会询问用户是否通过权限，包括位置、相机、联系人、短信、麦克风或日历等。\n  - Chrome 浏览器改善\n    用户可根据需求对Chrome进行改善，用户可将自动填充密码保存在手机中。\n  - APP关联\n    例如：用户手机邮箱收到内容中有Twitter链接的邮件，点击该链接可直接跳到Twitter应用。\n  - 安卓支付\n    Android是个开放平台，用户可以选择各种支付方式。Android Pay支持4.4以后系统的设备。\n  - 指纹支持\n    令手机厂商兴奋的是，谷歌官方开始i支持指纹识别功能，还可以保证支付安全。\n  - 电量管理\n    电池管理更加智能，可以分辨出睡眠还是活动，如果长时间不移动时，可以自动关闭一些APP。\n- 其他产品线\n  - 物联网操作系统 Brillo【能够在32MB或者64MB内存的设备上运行】\n  - Google Now 更加智能【能够识别上下文、音乐搜索等】\n  - 离线地图服务\n  - 新产品：Google Photos\n  - 虚拟现实【纸板VR眼镜Cardboard，支持Android和iOS双系统】\n  - JUMP 虚拟现实相机\n  - Android Studio 1.3版发布\n  - 发布Polymer网页应用开发包V1.0版\n\n\n\n","source":"_posts/2015.05.29 - 游戏开发.md","raw":"title: 游戏开发\ndate: 2015-05-29 23:04:29\ntags:\n- 游戏\n---\n\n## 2015.05.29 - 游戏开发主题\n\n#### Unity集成开发工具简介 - 李仙鹏\n\n- Unity IDE界面介绍\n- Unity IDE扩展介绍\n\n\n#### run-zombie-run HTML5 游戏 - 曾铭\n\n- HTML5 网页游戏，僵尸围攻对战游戏。支持局域网两名玩家，一名用键盘已经用手机打开手柄网页体感控制。\n\t- 技术关键词: web-socket, HTML5 Canvas\n\t- 柏茲模型算法参考 - [混沌邊緣的藝術－人工生命](http://redbug0314.blogspot.com/2009/06/blog-post.html)\n- 移动开发前端开发不分家，推荐阅读：\n\t- [HTML5 设计原理](http://developer.51cto.com/art/201103/247880_all.htm) 极其经典的一篇文章，从根本上理解 HTML5 来龙去脉。网上竟然找不到原始链接，神奇！\n- [Open Source](https://github.com/mithvv/run-zombie-run)\n- 链接有干货 ；）\n\n\n\n####Cocos2d闲扯与手游推荐 - 潘君\n\n#####Cocos2d  \n\t\n- 最早版本为oc版本，为cocos2d-iphone，[源码地址](https://code.google.com/p/cocos2d-iphone/)  \n\t\n- 现在C++移植版本cocos2d-x为手游两大跨平台手游开发引擎之一（另外一个为Unity）,[下载地址](http://www.cocos2d-x.org/)\n\n- 现在cocos2d-x维护主要为中国团队,触动科技\n\n- cocos2d基于[OpenGL ES](https://www.khronos.org/opengles/),与苹果官方游戏开发引擎Sprite一致\n\n其他参考资料：    \n\n* [App Store中开源游戏汇总](http://www.cnblogs.com/lingzhao/p/4165335.html)\n* [泰然论坛](https://www.khronos.org/opengles/)\n* [cocochina cocos讨论区](http://www.cocoachina.com/bbs/thread.php?fid=48)\n\n\n#####小游戏推荐\n\n- [Shadowmatic](https://itunes.apple.com/us/app/shadowmatic/id775888026?mt=8)  \n\t益智类3D游戏，通过对物体投射在墙上的影子拼凑构成生活中某一样事物。\n\t\n- [FRAMED](https://itunes.apple.com/us/app/framed/id886565180?mt=8)\n\t拼图类过关游戏，你必须自己观察游戏中的拼图，只有完成正确的拼图，主人公才能通过关卡中敌人的拦截。\n\n\n#### 游戏的起源与发展 - 张超耀\n- [游戏的故事：揭秘电子游戏诞生史](http://www.tudou.com/programs/view/cqT8Z-nZvn8/?from=timeline&isappinstalled=0)\n\t- 穿越时空，拯救世界，成为英雄……这些飘渺无际的虚幻想法，在这个时代，终于可以在“电子游戏”的世界中得以实现。而当我们在享受这个人类智慧结晶给我们带来的奇妙体验之时，有没有想过，是谁创造了如此这种娱乐方式？电子游戏又是如何发展蜕变的？ \n- [游戏的故事：从“硅与神经键”到动视暴雪](http://www.tudou.com/programs/view/cpwCix2sI48/?from=timeline&isappinstalled=0)\n\t- 暴雪出品，必属精品。这句流传在玩家中的8个字，是人们对暴雪这家游戏公司的肯定和赞美。暴雪为何能成为全球谈论最多的游戏公司之一？它又是否实至名归？游久网游戏的故事带你揭秘——从“硅与神经键”到动视暴雪。\n\n#### 游戏（APP）开发学习网站小游戏分享 - 杨志平\n- [udemy 全功能在线教育网站](https://www.udemy.com)\n\n `udemy = you + academy`\n \n Udemy目前有超过500万名注册用户，和超过22000门课程。与其他在线教育平台不同的是，Udemy不仅开放各种课程，更开放了教学的机会\n\n- [Ray Wenderlich iOS开发的百科全书](http://www.raywenderlich.com)\n\n`包含最新的iOS技术、最新语言等教程`\n\n随便提一下程序员学习利器 [Codecademy](http://www.codecademy.com) 免费, 起码做的比MOOC好\n\n\n##### 小游戏分享\n- Flappy Bird - 已下架\n- [Mr Jump](https://itunes.apple.com/cn/app/mr-jump/id955157084?mt=8&ign-mpt=uo%3D4) - 推荐\n- [fight!](https://itunes.apple.com/th/app/angry-birds-fight!/id933958078?mt=8) - 愤怒的小鸟新品，存在不足\n\n\n#### 2015 Google I/O 大会 - 王胜\n北京时间5月29日00:30，谷歌在美国旧金山召开了一年一度的开发者大会，发布了Android M等新品。\n- Android M 预览版\nAndroid M此次没有大规模新的API发布，而是回到质量上，改善用户体验。具体变动如下：\n  - 应用程序权限控制\n    应用程序在使用功能时才会询问用户是否通过权限，包括位置、相机、联系人、短信、麦克风或日历等。\n  - Chrome 浏览器改善\n    用户可根据需求对Chrome进行改善，用户可将自动填充密码保存在手机中。\n  - APP关联\n    例如：用户手机邮箱收到内容中有Twitter链接的邮件，点击该链接可直接跳到Twitter应用。\n  - 安卓支付\n    Android是个开放平台，用户可以选择各种支付方式。Android Pay支持4.4以后系统的设备。\n  - 指纹支持\n    令手机厂商兴奋的是，谷歌官方开始i支持指纹识别功能，还可以保证支付安全。\n  - 电量管理\n    电池管理更加智能，可以分辨出睡眠还是活动，如果长时间不移动时，可以自动关闭一些APP。\n- 其他产品线\n  - 物联网操作系统 Brillo【能够在32MB或者64MB内存的设备上运行】\n  - Google Now 更加智能【能够识别上下文、音乐搜索等】\n  - 离线地图服务\n  - 新产品：Google Photos\n  - 虚拟现实【纸板VR眼镜Cardboard，支持Android和iOS双系统】\n  - JUMP 虚拟现实相机\n  - Android Studio 1.3版发布\n  - 发布Polymer网页应用开发包V1.0版\n\n\n\n","slug":"2015.05.29 - 游戏开发","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyc000jtfptwrn8mlv4"},{"title":"《无主题》","date":"2015-05-22T23:04:29.000Z","_content":"\n## 2015.05.22\n#### [友盟自定义事件统计](http://dev.umeng.com/analytics/android-doc/integration#3_1) - 王胜\n- 应用上线后发现注册转换率很低，如何办？\n- 注册流程繁琐？那么具体哪一步流失量最大？\n- 友盟提供了自定义事件埋点功能，需要在对应的点击事件发生时，调用onEvent方法进行埋点。\n- 友盟同时提供了事件转换率，可以创建漏斗，每个漏斗是一个操作路径，由一系列自定义事件组成，这样可以观察每一步具体的点击量，从而有了事件的转换率。\n\n#### Android像素转换与Bitmap Config - 李仙鹏\n- 屏幕显示单位\n  - 屏幕的px与dp转换公式：px = dp * (dpi / 160)\n  - （dp：Density-independent pixel，独立密度像素；dpi：dots per inch）\n\n  6种常见dpi:\n\t* ldpi (low) ~120dpi\n        * mdpi (medium) ~160dpi\n        * hdpi (high) ~240dpi\n        * xhdpi (extra-high) ~320dpi\n        * xxhdpi (extra-extra-high) ~480dpi\n        * xxxhdpi (extra-extra-extra-high) ~640dpi\n\n- Bitmap Config\n  - 四种配置：ALPHA_8，RGB_565，ARGB_4444，ARGB_8888。其配置信息后面的数字相加表示图片在被编码为Bitmap后，原来图片的一个像素点所占的内存空间大小。以ARGB_8888为例，其一个像素点所占的内存空间为32个byte。\n  - Bitmap Config配置越高，图片显示越清晰，ARGB_8888为目前android的图片多默认编码方式\n\n#### 说说 LeanCloud - 曾铭\n- 数据存储\n  - [demo](https://leancloud.cn/docs/start.html)\n  - 移动开发后端的革命 ；）\n  - [parse.com](https://parse.com/)\n- 公司历史\n  - 陈士骏\n  - Youtube -> Delicious -> AVOS -> mixbit.com -> AVOSCloud -> LeanCloud\n  - 开放资源\n    - [Github](https://github.com/leancloud)\n    - [牛 X 开放文档](http://open.leancloud.cn/)\n  - Bigger 很重要\n\n\n\n####  Android Studio分享 - 吴明\n- android studio是google的亲儿子，肯定以后是必然形势。\n- android studio总体运行速度比Eclipse快。\n- android studio和Eclipse对比：\n   - 比Eclipse漂亮\n         - android studio可以设置开发代码的背景，而Eclipse只能用那一直到死用的开发背景，有时候想换换背景换换心情都不行。Android Stuido自带的Darcula主题的炫酷黑界面都还可以。想换别的主题也可以自己下载导入的。\n\n    - 比Eclipse速度快\n        - android studio的启动速度，响应速度，内存占用等等全面领先与Eclipse。\n\n    - 提示，补全更加智能，更加人性化。\n        - 自动提示补全(有点开发ios的味道)，现在android studio可以把快捷键设置为Eclipse的快捷方式\n\n    - 整合了Gradle构建工具\n         - gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。gradle能够完成构建、测试、发布和其他诸如软件打包、生成注释文档等等功能\n\n    - 支持Google Cloud Platform\n         - Android Studio支持本地的Google Cloud Platform(谷歌的云平台)，就是说你可以运行服务器端的代码。\n\n    - 强大的UI编辑器\n         - Android Studio的编辑器非常的智能。比如新建一个控件，控件的width和height属性会自动的补全，不用每次都要手动的打上两行 android:layout_width和android:layout_height。还有定义颜色后会自动把颜色显示在旁边（这个对我超级好用）。等等还有其他很多小细节做的都非常不错，大大提高了编辑UI的效率。\n\n    - 更完善的插件系统\n        - Android Studio中可以像Apple store那样浏览所有的插件，直接搜索，下载和管理它.\n\n    - 完美的整合版本控制软件\n        - 安装的时候就自带了如GitHub, CVN等等流行的版本控制工具\n\n    - Android Studio是Google推出的\n       -  Android Stuido是Google推出，专门为ANDROID“量身订做”的，Google的亲儿子。作为Android Developer大腿一定要抱紧。\n\n#### 平时闲暇时间喜欢看的微信公众号分享 - 张超耀\n- CocoaChina\n\t- 微信号：cocoachinabbs\n\t- 功能介绍：CocoaChina苹果开发中文社区官方微信，提供教程资源、app推广营销、招聘、外包以及培训信息、各类沙龙交流活动以及更多开发者服务。\n\n- iOS开发，唐巧\n\t- 微信号：iosDevTips\n\t- 功能介绍：唐巧，Info编辑，《iOS开发进阶》作者，现在在猿题库创业。开发过有道云笔记和猿题库的iOS客户端。该账号主要分享唐巧的博客文章以及他整理的一些iOS开发技巧。\n\n- 悟空的心灵花园\n - 微信号：wukong_000\n - 功能介绍：发现源自内心的喜悦！祝福你早日开启探索心灵和生命的旅程。\n\n- 36氪\n  - 微信号：wow36kr\n  - 功能介绍：36氪（36Kr.com）是中国领先的科技新媒体，报道最新的互联网科技新闻以及最有潜力的互联网创业企业。\n\n#### iOS 物理引擎的简单运用 - 杨志平\n##### iOS端的[Demo](https://github.com/ZhipingYang/UIKitDynamics)\n\nUIKitDynamics | 作用及用法\n----- | -----\nUIDynamicAnimator | 引擎载体\n[UIGravityBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/GravityViewController.m) | 重力行为\n[UICollisionBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/CollosionViewController.m) | 碰撞行为\n[UIAttachmentBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/AttachmentViewController.m) | 链接行为（弹簧效果）\n[UISnapBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/SnapViewController.m) | 吸附行为\n[UIPushBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/PushViewController.m) | 受力行为\n\n","source":"_posts/2015.05.22 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-05-22 23:04:29\ntags:\n---\n\n## 2015.05.22\n#### [友盟自定义事件统计](http://dev.umeng.com/analytics/android-doc/integration#3_1) - 王胜\n- 应用上线后发现注册转换率很低，如何办？\n- 注册流程繁琐？那么具体哪一步流失量最大？\n- 友盟提供了自定义事件埋点功能，需要在对应的点击事件发生时，调用onEvent方法进行埋点。\n- 友盟同时提供了事件转换率，可以创建漏斗，每个漏斗是一个操作路径，由一系列自定义事件组成，这样可以观察每一步具体的点击量，从而有了事件的转换率。\n\n#### Android像素转换与Bitmap Config - 李仙鹏\n- 屏幕显示单位\n  - 屏幕的px与dp转换公式：px = dp * (dpi / 160)\n  - （dp：Density-independent pixel，独立密度像素；dpi：dots per inch）\n\n  6种常见dpi:\n\t* ldpi (low) ~120dpi\n        * mdpi (medium) ~160dpi\n        * hdpi (high) ~240dpi\n        * xhdpi (extra-high) ~320dpi\n        * xxhdpi (extra-extra-high) ~480dpi\n        * xxxhdpi (extra-extra-extra-high) ~640dpi\n\n- Bitmap Config\n  - 四种配置：ALPHA_8，RGB_565，ARGB_4444，ARGB_8888。其配置信息后面的数字相加表示图片在被编码为Bitmap后，原来图片的一个像素点所占的内存空间大小。以ARGB_8888为例，其一个像素点所占的内存空间为32个byte。\n  - Bitmap Config配置越高，图片显示越清晰，ARGB_8888为目前android的图片多默认编码方式\n\n#### 说说 LeanCloud - 曾铭\n- 数据存储\n  - [demo](https://leancloud.cn/docs/start.html)\n  - 移动开发后端的革命 ；）\n  - [parse.com](https://parse.com/)\n- 公司历史\n  - 陈士骏\n  - Youtube -> Delicious -> AVOS -> mixbit.com -> AVOSCloud -> LeanCloud\n  - 开放资源\n    - [Github](https://github.com/leancloud)\n    - [牛 X 开放文档](http://open.leancloud.cn/)\n  - Bigger 很重要\n\n\n\n####  Android Studio分享 - 吴明\n- android studio是google的亲儿子，肯定以后是必然形势。\n- android studio总体运行速度比Eclipse快。\n- android studio和Eclipse对比：\n   - 比Eclipse漂亮\n         - android studio可以设置开发代码的背景，而Eclipse只能用那一直到死用的开发背景，有时候想换换背景换换心情都不行。Android Stuido自带的Darcula主题的炫酷黑界面都还可以。想换别的主题也可以自己下载导入的。\n\n    - 比Eclipse速度快\n        - android studio的启动速度，响应速度，内存占用等等全面领先与Eclipse。\n\n    - 提示，补全更加智能，更加人性化。\n        - 自动提示补全(有点开发ios的味道)，现在android studio可以把快捷键设置为Eclipse的快捷方式\n\n    - 整合了Gradle构建工具\n         - gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。gradle能够完成构建、测试、发布和其他诸如软件打包、生成注释文档等等功能\n\n    - 支持Google Cloud Platform\n         - Android Studio支持本地的Google Cloud Platform(谷歌的云平台)，就是说你可以运行服务器端的代码。\n\n    - 强大的UI编辑器\n         - Android Studio的编辑器非常的智能。比如新建一个控件，控件的width和height属性会自动的补全，不用每次都要手动的打上两行 android:layout_width和android:layout_height。还有定义颜色后会自动把颜色显示在旁边（这个对我超级好用）。等等还有其他很多小细节做的都非常不错，大大提高了编辑UI的效率。\n\n    - 更完善的插件系统\n        - Android Studio中可以像Apple store那样浏览所有的插件，直接搜索，下载和管理它.\n\n    - 完美的整合版本控制软件\n        - 安装的时候就自带了如GitHub, CVN等等流行的版本控制工具\n\n    - Android Studio是Google推出的\n       -  Android Stuido是Google推出，专门为ANDROID“量身订做”的，Google的亲儿子。作为Android Developer大腿一定要抱紧。\n\n#### 平时闲暇时间喜欢看的微信公众号分享 - 张超耀\n- CocoaChina\n\t- 微信号：cocoachinabbs\n\t- 功能介绍：CocoaChina苹果开发中文社区官方微信，提供教程资源、app推广营销、招聘、外包以及培训信息、各类沙龙交流活动以及更多开发者服务。\n\n- iOS开发，唐巧\n\t- 微信号：iosDevTips\n\t- 功能介绍：唐巧，Info编辑，《iOS开发进阶》作者，现在在猿题库创业。开发过有道云笔记和猿题库的iOS客户端。该账号主要分享唐巧的博客文章以及他整理的一些iOS开发技巧。\n\n- 悟空的心灵花园\n - 微信号：wukong_000\n - 功能介绍：发现源自内心的喜悦！祝福你早日开启探索心灵和生命的旅程。\n\n- 36氪\n  - 微信号：wow36kr\n  - 功能介绍：36氪（36Kr.com）是中国领先的科技新媒体，报道最新的互联网科技新闻以及最有潜力的互联网创业企业。\n\n#### iOS 物理引擎的简单运用 - 杨志平\n##### iOS端的[Demo](https://github.com/ZhipingYang/UIKitDynamics)\n\nUIKitDynamics | 作用及用法\n----- | -----\nUIDynamicAnimator | 引擎载体\n[UIGravityBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/GravityViewController.m) | 重力行为\n[UICollisionBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/CollosionViewController.m) | 碰撞行为\n[UIAttachmentBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/AttachmentViewController.m) | 链接行为（弹簧效果）\n[UISnapBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/SnapViewController.m) | 吸附行为\n[UIPushBehavior](https://github.com/ZhipingYang/UIKitDynamics/blob/master/DynamicsDemo/PushViewController.m) | 受力行为\n\n","slug":"2015.05.22 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyf000mtfptqr8a4d0j"},{"title":"《无主题》","date":"2015-05-15T23:04:29.000Z","_content":"\n## 2015.05.15\n#### Android emoji表情分享 - 吴明\n\n- 什么是emoji表情？\n\n\t- 一套起源于日本的12x12像素表情符号，由栗田穣崇（Shigetaka Kurit）创作，最早在日本网络及手机用户中流行.\n\n- emoji表情手机的支持？\n    - IOS\n\t\t- iOS 4以及之前版本, 采用Softbank编码.\n\t\t- iOS 5以及之后的版本，或者OSX Lion之后的系统, 则改为使用了Unicode6.0编码\n\t\t \n    - Android\n\t    - 在android4.4开始支持emoji表情，Unicode编码,如sougou，谷歌等输入法都支持emoji表情。\n \n\n- emoji展示过程\n\n\t- 显示emoji表情----选中emoji表情----unicod编码字符串----ios或者android对unicode编码字符串处理-----如果是emoji表情编码---则从系统中显示相应的emoji表情图片。\n\n- emoji表情的存储\n\n    - iPhone：统一用unicode6.0编码保存\n\n\t- android或wp其他手机： 如果没有emoji表情库，将无法输入。针对输入问题,将统一采用unicode6.0编码存储，UBB代码.\n\n    - 数据库存储：存数据以UTF-8编码用3个字节去存储的，而emoji表情要用4个字节的utf8，也就是utf8mb4格式. \n        - 数据库编码转为utf8mb4,\n \t\t- emoji表情转为支持的utf-8，如转为UBB代码([emoji]2600[/emoji])，HTML转义字符(&#x2600)\n- emoji表情不支持处理\n    - [链接地址1](http://ragnraok.github.io/android-emoji-font-method.html)\n    - [链接地址2](http://bbs.csdn.net/topics/390055415)\n\n#### [iOS 创建静态库](http://192.168.37.105:9092/boards/2/topics/6) -- 顾鹏凌  \n\n#### iOS国际化语言&CodeRunner -- 张超耀\n- iOS国际化语言\n\t- iOS国际化语言是适配系统语言展示同一语义的不同语言。\n\t- 在工作目录结构文件下，单击`InfoPlist.strings`，在`Localization`栏添加语言。\n\t- 添加`\"Key\"=\"value\"`; 然后使用时用`NSLocalizedString(@\"key\", @\"\")`; 读取内容.`Localization.strings English文`件添加` \"key\" = \"english value\"`;`Localization.strings English`文件添加 `\"key\" = \"中文内容\"`;\n\t- 保持需要国际化的语言对应同一key值：比如`English`的添加`CFBundleDisplayName=\"China\"`;`Chinese`文件添加`CFBundleDisplayName=\"中国\"`.\n\t- 使用：`NSString * str = NSLocalizedString(@\"CFBundleDisplayName\",nil]`;\n\t\n\t\n- [CodeRunner](https://itunes.apple.com/us/app/coderunner/id433335799?mt=12)\n\t- CodeRunner是Mac下一款可编辑多种主流编程语言，并且一键运行检测结果；带有缩进、自动补完、语法高亮和智能括号匹配等特性的APP。 \n\t- Description \n\t\t- [官方描述](https://coderunnerapp.com):CodeRunner is the easiest way to write code on your Mac. You can run code in almost any language instantly, and you'll be surprised by the powerful set of features in such a lightweight and easy-to-use editor.\n\t\t- [iTunesStore](https://itunes.apple.com/us/app/coderunner/id433335799?mt=12):Edit and run code in any programming language with just a single click. With CodeRunner, It has never been easier to write and test code, run scripts, work with algorithms, or simply experiment with a new coding or scripting language.\n\n","source":"_posts/2015.05.15 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-05-15 23:04:29\ntags:\n---\n\n## 2015.05.15\n#### Android emoji表情分享 - 吴明\n\n- 什么是emoji表情？\n\n\t- 一套起源于日本的12x12像素表情符号，由栗田穣崇（Shigetaka Kurit）创作，最早在日本网络及手机用户中流行.\n\n- emoji表情手机的支持？\n    - IOS\n\t\t- iOS 4以及之前版本, 采用Softbank编码.\n\t\t- iOS 5以及之后的版本，或者OSX Lion之后的系统, 则改为使用了Unicode6.0编码\n\t\t \n    - Android\n\t    - 在android4.4开始支持emoji表情，Unicode编码,如sougou，谷歌等输入法都支持emoji表情。\n \n\n- emoji展示过程\n\n\t- 显示emoji表情----选中emoji表情----unicod编码字符串----ios或者android对unicode编码字符串处理-----如果是emoji表情编码---则从系统中显示相应的emoji表情图片。\n\n- emoji表情的存储\n\n    - iPhone：统一用unicode6.0编码保存\n\n\t- android或wp其他手机： 如果没有emoji表情库，将无法输入。针对输入问题,将统一采用unicode6.0编码存储，UBB代码.\n\n    - 数据库存储：存数据以UTF-8编码用3个字节去存储的，而emoji表情要用4个字节的utf8，也就是utf8mb4格式. \n        - 数据库编码转为utf8mb4,\n \t\t- emoji表情转为支持的utf-8，如转为UBB代码([emoji]2600[/emoji])，HTML转义字符(&#x2600)\n- emoji表情不支持处理\n    - [链接地址1](http://ragnraok.github.io/android-emoji-font-method.html)\n    - [链接地址2](http://bbs.csdn.net/topics/390055415)\n\n#### [iOS 创建静态库](http://192.168.37.105:9092/boards/2/topics/6) -- 顾鹏凌  \n\n#### iOS国际化语言&CodeRunner -- 张超耀\n- iOS国际化语言\n\t- iOS国际化语言是适配系统语言展示同一语义的不同语言。\n\t- 在工作目录结构文件下，单击`InfoPlist.strings`，在`Localization`栏添加语言。\n\t- 添加`\"Key\"=\"value\"`; 然后使用时用`NSLocalizedString(@\"key\", @\"\")`; 读取内容.`Localization.strings English文`件添加` \"key\" = \"english value\"`;`Localization.strings English`文件添加 `\"key\" = \"中文内容\"`;\n\t- 保持需要国际化的语言对应同一key值：比如`English`的添加`CFBundleDisplayName=\"China\"`;`Chinese`文件添加`CFBundleDisplayName=\"中国\"`.\n\t- 使用：`NSString * str = NSLocalizedString(@\"CFBundleDisplayName\",nil]`;\n\t\n\t\n- [CodeRunner](https://itunes.apple.com/us/app/coderunner/id433335799?mt=12)\n\t- CodeRunner是Mac下一款可编辑多种主流编程语言，并且一键运行检测结果；带有缩进、自动补完、语法高亮和智能括号匹配等特性的APP。 \n\t- Description \n\t\t- [官方描述](https://coderunnerapp.com):CodeRunner is the easiest way to write code on your Mac. You can run code in almost any language instantly, and you'll be surprised by the powerful set of features in such a lightweight and easy-to-use editor.\n\t\t- [iTunesStore](https://itunes.apple.com/us/app/coderunner/id433335799?mt=12):Edit and run code in any programming language with just a single click. With CodeRunner, It has never been easier to write and test code, run scripts, work with algorithms, or simply experiment with a new coding or scripting language.\n\n","slug":"2015.05.15 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyg000ntfptsfl8yfgs"},{"title":"《无主题》","date":"2015-05-08T23:04:29.000Z","_content":"## 2015.05.08\n\n#### 构建基于Jenkins+github的持续集成环境 - 张超耀\n- [什么是持续集成](http://baike.baidu.com/link?url=a4772W-jg95m7RgEE3NL6wkELXlGUgCmJesUg2anLEmzzgbKHhwpodx2fvSDEOG2eFWB3NYfzeymvjn7Q4Ayxa#4)\n\n- 持续集成的流程\n\t- CI服务器控制持续集成的整个过程，轮询代码库更新，根据预定义的脚本进行项目的构建，服务器将任务分配到Slave端\n\n- 为什么采用Jenkins+github的持续集成环境\n\t- Jenins是现在非常流行的持续集成CI服务器，Jenkins易于安装，不需要数据库的支持，直接通过Web界面进行配置，而且集成了Email的通知机制，具有丰富的插件。\n\t- 对于版本控制，SVN & Git，Jenkins都有提供插件支持\n\t\n- [Jenkins安装](http://jenkins-ci.org)\n     - 安装成功，键入http://localhost:8080进入\n- 丰富插件安装\n- 环境配置\n- 构建项目\n- 配置构建方法\n\n####  [Axure工具分享](http://www.webppd.com/thread-8161-1-1.html) - 吴明\n\n- Axure是什么？\n\t- Axure界面原型设计工具，无须懂得控制人机交互的事件处理，设计好后可以导出html格式跨平台开发使用。\n- 原型工具对比：\n  - 使用网页制作软件创建：可以直接操作HTML文件，更接近真实。缺点，你需要掌握HTML语法，掌握复杂的网页制作工具。操作复杂性高。\n  - visio，可以快速的创建单个页面，也可以用创建，缺点：最多只能做到页面直接的关联，按钮，链接上无法创建事件，死板。无法作出接近真实的效果，无法生成HTML文件。\n  - Axure，Axure可以以所见即所得的方式创建界面原型，优点：操作者无须懂的HTML语法，无须懂得控制人机交互的事件处理，例如页面跳转时、命令按钮按下时系统响应 程序脚本（JAVA Script）。因此很适合业务需求分析人员使用。生成的页面，串接在一起，可以进行操作，模拟场景，让系统“动”起来。\n\n- 怎么下载安装Axure\n  - 网上下载axure RP7.0安装(如果有需要的的话下中文包)\n- Axure的使用：\n   - [axure工具界面介绍](http://www.luexiao.com/group/blog/111495)\n   - 组件\n   - [导入第三方组件](http://jingyan.baidu.com/article/bea41d437015bcb4c51be615.html),下载IOS8的组件，android的组件\n   - 常用组件使用:\n       - [Dynamic Pane(动态面板)](http://blog.163.com/summer_wang/blog/static/21470903220132675433741/):\n\n####  [ARC Welder](https://chrome.google.com/webstore/detail/arc-welder/emfinbmielocnlhgmfkkmkngdoccbadn) -王胜\n\n- ARC Welder是一个Chrome插件，可以直接运行原生的安卓APP应用程序\n- 该插件需要Chrome的版本在40.x以上\n- 目前还处于不断完善阶段，所以一些特大游戏类型的App可能跑不起来\n\n#### 前端开发上手工具介绍 - 曾铭\n- 静态网页开发\n- SublimeText\n\t- Editor vs IDE : 丢掉 Dreamweaver, 根据情况选择 SublimeText & WebStorm\n\t- [Sublime Text 全程指南](http://lucida.me/blog/sublime-text-complete-guide/)\n\t- [实用技巧](http://www.zhihu.com/question/19976788)\n\t- [快捷键](http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html)\n\t- [查看默认支持语言配置文件](http://stackoverflow.com/questions/21190392/how-to-change-default-code-snippets-in-sublime-text-3)\n\t- 插件\n\t\t- emmet: [cheat-sheet](http://docs.emmet.io/cheat-sheet/) \n\t\t- BracketHighlighter: 块高亮\n\t\t- HTML5: snippet\n\t\t- SublimeLinter: 校验\n\t\t- livestyle: live edit css\n- powder\n\t- [pow](http://pow.cx/) 37signals 出品，质量保证！\n\t- 零配置构建网站服务器，管理极轻量，支持局域网访问\n\t- `powder link web-name` 一条命令搞定\n\t- 适合静态网页开发，（或 ruby 动态网页开发）\n- Demo\n\n","source":"_posts/2015.05.08 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-05-08 23:04:29\ntags:\n---\n## 2015.05.08\n\n#### 构建基于Jenkins+github的持续集成环境 - 张超耀\n- [什么是持续集成](http://baike.baidu.com/link?url=a4772W-jg95m7RgEE3NL6wkELXlGUgCmJesUg2anLEmzzgbKHhwpodx2fvSDEOG2eFWB3NYfzeymvjn7Q4Ayxa#4)\n\n- 持续集成的流程\n\t- CI服务器控制持续集成的整个过程，轮询代码库更新，根据预定义的脚本进行项目的构建，服务器将任务分配到Slave端\n\n- 为什么采用Jenkins+github的持续集成环境\n\t- Jenins是现在非常流行的持续集成CI服务器，Jenkins易于安装，不需要数据库的支持，直接通过Web界面进行配置，而且集成了Email的通知机制，具有丰富的插件。\n\t- 对于版本控制，SVN & Git，Jenkins都有提供插件支持\n\t\n- [Jenkins安装](http://jenkins-ci.org)\n     - 安装成功，键入http://localhost:8080进入\n- 丰富插件安装\n- 环境配置\n- 构建项目\n- 配置构建方法\n\n####  [Axure工具分享](http://www.webppd.com/thread-8161-1-1.html) - 吴明\n\n- Axure是什么？\n\t- Axure界面原型设计工具，无须懂得控制人机交互的事件处理，设计好后可以导出html格式跨平台开发使用。\n- 原型工具对比：\n  - 使用网页制作软件创建：可以直接操作HTML文件，更接近真实。缺点，你需要掌握HTML语法，掌握复杂的网页制作工具。操作复杂性高。\n  - visio，可以快速的创建单个页面，也可以用创建，缺点：最多只能做到页面直接的关联，按钮，链接上无法创建事件，死板。无法作出接近真实的效果，无法生成HTML文件。\n  - Axure，Axure可以以所见即所得的方式创建界面原型，优点：操作者无须懂的HTML语法，无须懂得控制人机交互的事件处理，例如页面跳转时、命令按钮按下时系统响应 程序脚本（JAVA Script）。因此很适合业务需求分析人员使用。生成的页面，串接在一起，可以进行操作，模拟场景，让系统“动”起来。\n\n- 怎么下载安装Axure\n  - 网上下载axure RP7.0安装(如果有需要的的话下中文包)\n- Axure的使用：\n   - [axure工具界面介绍](http://www.luexiao.com/group/blog/111495)\n   - 组件\n   - [导入第三方组件](http://jingyan.baidu.com/article/bea41d437015bcb4c51be615.html),下载IOS8的组件，android的组件\n   - 常用组件使用:\n       - [Dynamic Pane(动态面板)](http://blog.163.com/summer_wang/blog/static/21470903220132675433741/):\n\n####  [ARC Welder](https://chrome.google.com/webstore/detail/arc-welder/emfinbmielocnlhgmfkkmkngdoccbadn) -王胜\n\n- ARC Welder是一个Chrome插件，可以直接运行原生的安卓APP应用程序\n- 该插件需要Chrome的版本在40.x以上\n- 目前还处于不断完善阶段，所以一些特大游戏类型的App可能跑不起来\n\n#### 前端开发上手工具介绍 - 曾铭\n- 静态网页开发\n- SublimeText\n\t- Editor vs IDE : 丢掉 Dreamweaver, 根据情况选择 SublimeText & WebStorm\n\t- [Sublime Text 全程指南](http://lucida.me/blog/sublime-text-complete-guide/)\n\t- [实用技巧](http://www.zhihu.com/question/19976788)\n\t- [快捷键](http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html)\n\t- [查看默认支持语言配置文件](http://stackoverflow.com/questions/21190392/how-to-change-default-code-snippets-in-sublime-text-3)\n\t- 插件\n\t\t- emmet: [cheat-sheet](http://docs.emmet.io/cheat-sheet/) \n\t\t- BracketHighlighter: 块高亮\n\t\t- HTML5: snippet\n\t\t- SublimeLinter: 校验\n\t\t- livestyle: live edit css\n- powder\n\t- [pow](http://pow.cx/) 37signals 出品，质量保证！\n\t- 零配置构建网站服务器，管理极轻量，支持局域网访问\n\t- `powder link web-name` 一条命令搞定\n\t- 适合静态网页开发，（或 ruby 动态网页开发）\n- Demo\n\n","slug":"2015.05.08 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyh000otfpt29eiwlpl"},{"title":"《无主题》","date":"2015-04-24T23:04:29.000Z","_content":"\n## 2015.04.24\n\n#### 项目开发前期注意细节探讨 - 张超耀\n- 需求明朗\n\t- 最好有明确的需求说明文档\n\t- 能够及时和设计、PM沟通反馈，有效跟进需求变更\n\t- 工程师前期做好想法融合，先把需求想法抛出，不要等到研发过程中\n- 设计明确 \n\t- 在研发过程中，功能和设计达到高度统一，不要做功能的时候忽略UI设计(前期UI设计模块尽量不要留下太多后期需要填补的坑)\n- 代码质量 \n\t- 注释:在代码中一些自己写的方法尽量注释(功能、参数，使用)\n\t- code review(代码review很重要)\n\t- 复用\n- 团队协作\n\t- 沟通\n\t- 前期规划\n\t- 后期测试\n\n#### 分享 - 吴明\n- [快递100](http://www.kuaidi100.com/)\n   - 方便查询附近快递员电话\n   - 扫描快递单号跟踪快递信息\n- [Axure RP原型设计](http://rj.baidu.com/soft/detail/15574.html?ald)\n   - Axure RP是一个专业的快速原型设计工具\n   - Axure RP生成的原型文件是网页版，跨平台支持\n   - Axure RP工具操作。\n\n#### 『世界那么大，我想去看看』之网络 - 曾铭\n- 风景：\n\t- Google、twitter、dropbox、gravatar、Github……\n\t- 体验优秀产品/技术，提升产品/技术视野\n- [Great Firewall of China](http://zh.wikipedia.org/wiki/Shadowsocks) 存在的绝对性与『合理性』\n- 技术手段\n\t- DNS、host 都不算\n\t- 肉身\n\t- VPN\n\t- socket [goagent](http://zh.wikipedia.org/wiki/GoAgent) [shadowsocks](http://zh.wikipedia.org/wiki/Shadowsocks)\n\t- APN\n- 实践\n\t- OS X - system - network\n\t\t- 网络顺序\n\t\t- DNS，pac\n\t- [chrome - proxy-switchyomega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN) 旧版 [Proxy SwitchySharp](https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?hl=zh-CN)\n\t- 珍爱生命，远离免费\n\t\t- [云梯](https://www.cryptvline.com/?r=a67ffaca1d29800e)\n\t\t- [crolax](https://gocrolax.com/)\n","source":"_posts/2015.04.24 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-04-24 23:04:29\ntags:\n---\n\n## 2015.04.24\n\n#### 项目开发前期注意细节探讨 - 张超耀\n- 需求明朗\n\t- 最好有明确的需求说明文档\n\t- 能够及时和设计、PM沟通反馈，有效跟进需求变更\n\t- 工程师前期做好想法融合，先把需求想法抛出，不要等到研发过程中\n- 设计明确 \n\t- 在研发过程中，功能和设计达到高度统一，不要做功能的时候忽略UI设计(前期UI设计模块尽量不要留下太多后期需要填补的坑)\n- 代码质量 \n\t- 注释:在代码中一些自己写的方法尽量注释(功能、参数，使用)\n\t- code review(代码review很重要)\n\t- 复用\n- 团队协作\n\t- 沟通\n\t- 前期规划\n\t- 后期测试\n\n#### 分享 - 吴明\n- [快递100](http://www.kuaidi100.com/)\n   - 方便查询附近快递员电话\n   - 扫描快递单号跟踪快递信息\n- [Axure RP原型设计](http://rj.baidu.com/soft/detail/15574.html?ald)\n   - Axure RP是一个专业的快速原型设计工具\n   - Axure RP生成的原型文件是网页版，跨平台支持\n   - Axure RP工具操作。\n\n#### 『世界那么大，我想去看看』之网络 - 曾铭\n- 风景：\n\t- Google、twitter、dropbox、gravatar、Github……\n\t- 体验优秀产品/技术，提升产品/技术视野\n- [Great Firewall of China](http://zh.wikipedia.org/wiki/Shadowsocks) 存在的绝对性与『合理性』\n- 技术手段\n\t- DNS、host 都不算\n\t- 肉身\n\t- VPN\n\t- socket [goagent](http://zh.wikipedia.org/wiki/GoAgent) [shadowsocks](http://zh.wikipedia.org/wiki/Shadowsocks)\n\t- APN\n- 实践\n\t- OS X - system - network\n\t\t- 网络顺序\n\t\t- DNS，pac\n\t- [chrome - proxy-switchyomega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN) 旧版 [Proxy SwitchySharp](https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?hl=zh-CN)\n\t- 珍爱生命，远离免费\n\t\t- [云梯](https://www.cryptvline.com/?r=a67ffaca1d29800e)\n\t\t- [crolax](https://gocrolax.com/)\n","slug":"2015.04.24 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyj000ptfptrqyj1f36"},{"title":"《无主题》","date":"2015-04-17T23:04:29.000Z","_content":"## 2015.04.17\n\n#### 优秀APP分享 - 张超耀\n- [same](https://ohsame.com)\n   - same追求和而不同，是由9种频道模式，177860个频道组成的，玩法多样，富有创造力的社区。\n   - 在same，你可以建立一个个专属于你的音乐频道来表达自我情感。\n   - same电影，体味人生：在same里看预告，写影评，记录你每一次的观影体验。\n   - same同时可以虚拟打卡，跟踪自己的生活轨迹。\n   - 可以用图文来记录自己的生活点滴\n   - 如果你有一些纠结的难题，或你对一些事有疑惑，或者你干脆是个天秤座……都可以来投票频道，看看大家的想法。\n\n#### App 上线后如何收集分析错误日志 - 王胜\n- 需求：App上线后，如何收集用户使用过程中产生的异常日志？\n- 自己开发？\n  - 需要投入人力和时间，前端和后台都需要开发，而且可能是一个不断优化的过程\n- 使用专业的第三方工具\n  - 不需要投入额外人力，就可以快速集成专业日志收集功能\n  - [友盟](http://www.umeng.com/)\n    需要注意事项：\n    - Android 每次混淆编译后需要保存mapping.txt文件，用来还原原始的异常堆栈。\n    - iOS 查看异常信息，点击出错内存地址的编码的那个链接，有执行命令，可通过在发版的电脑上执行获取原始的异常堆栈\n  - 其他第三方工具\n    - [TalkingData](https://www.talkingdata.com/products.jsp)\n    - [Bugly](http://bugly.qq.com/)\n\n#### iOS-UINavigationBar-backBarButtonItem 的一种定制方式 - 曾铭\n\n- 需求：UINavigationBar 返回按钮使用自定义图标\n- 图标用 `setBackIndicatorImage:` + `setBackIndicatorTransitionMaskImage:` 搞定\n- 问题1: 如何去掉文字？\n\t- 修改文字定位偏移量？`setBackButtonTitlePositionAdjustment`\n- 问题2: title 不居中?\n\t- 在 BaseViewController 中 set backButtonItem\n- 问题3: better? -\\> library?\n\t- UIViewController Category.\n- [参考链接](http://justabeech.com/2014/02/24/empty-back-button-on-ios7/)\n\n####[android多国语言适配](http://blog.csdn.net/dyllove98/article/details/8831908) - 吴明\n - android语言信息都是读取strings.xml(项目/res/values/strings.xml)文件指定key的索引值。\n \n - android语言适配需要在-项目/res下新建不同的语言目录(文件命名规范:values-zh(国家)-rTW(r+区域))如: \n       默认:项目/res/values\n       中国台湾:项目/res/values-zh-rTW\n       中国简体:项目/resvalues-zh-rCN\n\n - 用户启动APP默认读取跟android系统一样的语言文件，如没有配置各国语言则默认读取系统默认语言文件(项目/res/vlues/strings.xml)\n \n - 正在使用app怎么切换语言？\n    <ol>\n    <li>sharePreferences存入设置语言：</li>\n    <pre>\n\tSharences sharedPreferences = getActivity().getSharedPrefeivity().getPackageName(), 0);\n\tsharedPreferences.edit().putString(\"language\", lanAtr).commit();\n\t</pre>\n    <li>语言更新后，对于之前出现且目前仍旧存活的activity，语言设置是不生效的。可以通过重启对应的activity，让语言及时生效。\n    </li>\n    \n      <pre>private void restart() {\n              Intent it = new Intent(getActivity(), MainActivity.class); //MainActivity是你想要重启的activity\n              it.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n              it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n               getActivity().startActivity(it);\n\t   }\n      </pre>\n      </ol>\n\n","source":"_posts/2015.04.17 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-04-17 23:04:29\ntags:\n---\n## 2015.04.17\n\n#### 优秀APP分享 - 张超耀\n- [same](https://ohsame.com)\n   - same追求和而不同，是由9种频道模式，177860个频道组成的，玩法多样，富有创造力的社区。\n   - 在same，你可以建立一个个专属于你的音乐频道来表达自我情感。\n   - same电影，体味人生：在same里看预告，写影评，记录你每一次的观影体验。\n   - same同时可以虚拟打卡，跟踪自己的生活轨迹。\n   - 可以用图文来记录自己的生活点滴\n   - 如果你有一些纠结的难题，或你对一些事有疑惑，或者你干脆是个天秤座……都可以来投票频道，看看大家的想法。\n\n#### App 上线后如何收集分析错误日志 - 王胜\n- 需求：App上线后，如何收集用户使用过程中产生的异常日志？\n- 自己开发？\n  - 需要投入人力和时间，前端和后台都需要开发，而且可能是一个不断优化的过程\n- 使用专业的第三方工具\n  - 不需要投入额外人力，就可以快速集成专业日志收集功能\n  - [友盟](http://www.umeng.com/)\n    需要注意事项：\n    - Android 每次混淆编译后需要保存mapping.txt文件，用来还原原始的异常堆栈。\n    - iOS 查看异常信息，点击出错内存地址的编码的那个链接，有执行命令，可通过在发版的电脑上执行获取原始的异常堆栈\n  - 其他第三方工具\n    - [TalkingData](https://www.talkingdata.com/products.jsp)\n    - [Bugly](http://bugly.qq.com/)\n\n#### iOS-UINavigationBar-backBarButtonItem 的一种定制方式 - 曾铭\n\n- 需求：UINavigationBar 返回按钮使用自定义图标\n- 图标用 `setBackIndicatorImage:` + `setBackIndicatorTransitionMaskImage:` 搞定\n- 问题1: 如何去掉文字？\n\t- 修改文字定位偏移量？`setBackButtonTitlePositionAdjustment`\n- 问题2: title 不居中?\n\t- 在 BaseViewController 中 set backButtonItem\n- 问题3: better? -\\> library?\n\t- UIViewController Category.\n- [参考链接](http://justabeech.com/2014/02/24/empty-back-button-on-ios7/)\n\n####[android多国语言适配](http://blog.csdn.net/dyllove98/article/details/8831908) - 吴明\n - android语言信息都是读取strings.xml(项目/res/values/strings.xml)文件指定key的索引值。\n \n - android语言适配需要在-项目/res下新建不同的语言目录(文件命名规范:values-zh(国家)-rTW(r+区域))如: \n       默认:项目/res/values\n       中国台湾:项目/res/values-zh-rTW\n       中国简体:项目/resvalues-zh-rCN\n\n - 用户启动APP默认读取跟android系统一样的语言文件，如没有配置各国语言则默认读取系统默认语言文件(项目/res/vlues/strings.xml)\n \n - 正在使用app怎么切换语言？\n    <ol>\n    <li>sharePreferences存入设置语言：</li>\n    <pre>\n\tSharences sharedPreferences = getActivity().getSharedPrefeivity().getPackageName(), 0);\n\tsharedPreferences.edit().putString(\"language\", lanAtr).commit();\n\t</pre>\n    <li>语言更新后，对于之前出现且目前仍旧存活的activity，语言设置是不生效的。可以通过重启对应的activity，让语言及时生效。\n    </li>\n    \n      <pre>private void restart() {\n              Intent it = new Intent(getActivity(), MainActivity.class); //MainActivity是你想要重启的activity\n              it.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n              it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n               getActivity().startActivity(it);\n\t   }\n      </pre>\n      </ol>\n\n","slug":"2015.04.17 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyl000qtfptf0celdr4"},{"title":"《无主题》","date":"2015-04-10T23:04:29.000Z","_content":"\n## 2015.04.10\n\n#### Redmine - 王胜\n* [Redmine](http://www.redmine.org/)是免费开源的基于ROR的项目管理工具\n* UI及交互实属开源软件中难得之作\n* Issue支持多种跟踪标签【如bug、功能、UI】，每种跟踪标签可单独设置工作流\n* 支持日历、甘特图等可视化进度管理\n* 支持WIKI语法，方便协作编辑文档\n* 可以集成SCM工具【如Git、Subversion、Mercurial等等】，可直接浏览源码进行Code Review\n* 丰富的插件支持\n\n#### APP分享 -吴明\n- [生日管家](http://www.365shengri.cn/)\n\t- 工具类APP\n\t- 公历农历记录用生日\n\t- 生日提醒\n\t- 生日，每天运势\n\t- 节日礼物推荐及购物\n\t- 节日祝福语，节日贺卡\n\t- 会员交流：同生缘\n\n\n#### iOS push 调试方法 - 曾铭\n* Bundle ID: appid & profile(cer(privatekey)+appid)\n* Update profile to latest\n* Build to iPhone: `adhoc_profile`, has `certificate`\n* Get push token （建议用 copy 的方法）\n\t* Enable notification in Setting\n* Export .p12 from _Keychain Access_ : has `private key`\n* .p12 to .pem\n* [iOS 命令行调试工具 houston](http://nomad-cli.com/)  Apn CLI push to token: if production, add production param\n* 👌!\n* Server apn debug （注意 production 参数）\n* 注意：\n    * 调试环境最小化（用 apn cli 代替 服务器 push）\n    * 关注 关键点（ profile中的私钥，pushtoken 有没有拿到）做追溯\n\n#### storyboard中push变成present的情况讨论 - 张超耀\n* 在同一storyboard中有三个界面跳转用到push，其中一个效果变成present，而且这种情况只是在iOS7下才出现的，在iOS8下是正常的。目前觉得出现这种情况的可能性主要是由于当前界面的跳转实现是代码控制，其他两个正常界面的跳转是storyboard控制的,但是这种影响有点儿没有说服力。不过这个可能性需要进一步测试（下周报告...）！\n","source":"_posts/2015.04.10 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-04-10 23:04:29\ntags:\n---\n\n## 2015.04.10\n\n#### Redmine - 王胜\n* [Redmine](http://www.redmine.org/)是免费开源的基于ROR的项目管理工具\n* UI及交互实属开源软件中难得之作\n* Issue支持多种跟踪标签【如bug、功能、UI】，每种跟踪标签可单独设置工作流\n* 支持日历、甘特图等可视化进度管理\n* 支持WIKI语法，方便协作编辑文档\n* 可以集成SCM工具【如Git、Subversion、Mercurial等等】，可直接浏览源码进行Code Review\n* 丰富的插件支持\n\n#### APP分享 -吴明\n- [生日管家](http://www.365shengri.cn/)\n\t- 工具类APP\n\t- 公历农历记录用生日\n\t- 生日提醒\n\t- 生日，每天运势\n\t- 节日礼物推荐及购物\n\t- 节日祝福语，节日贺卡\n\t- 会员交流：同生缘\n\n\n#### iOS push 调试方法 - 曾铭\n* Bundle ID: appid & profile(cer(privatekey)+appid)\n* Update profile to latest\n* Build to iPhone: `adhoc_profile`, has `certificate`\n* Get push token （建议用 copy 的方法）\n\t* Enable notification in Setting\n* Export .p12 from _Keychain Access_ : has `private key`\n* .p12 to .pem\n* [iOS 命令行调试工具 houston](http://nomad-cli.com/)  Apn CLI push to token: if production, add production param\n* 👌!\n* Server apn debug （注意 production 参数）\n* 注意：\n    * 调试环境最小化（用 apn cli 代替 服务器 push）\n    * 关注 关键点（ profile中的私钥，pushtoken 有没有拿到）做追溯\n\n#### storyboard中push变成present的情况讨论 - 张超耀\n* 在同一storyboard中有三个界面跳转用到push，其中一个效果变成present，而且这种情况只是在iOS7下才出现的，在iOS8下是正常的。目前觉得出现这种情况的可能性主要是由于当前界面的跳转实现是代码控制，其他两个正常界面的跳转是storyboard控制的,但是这种影响有点儿没有说服力。不过这个可能性需要进一步测试（下周报告...）！\n","slug":"2015.04.10 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyn000rtfpt20fj7v9e"},{"title":"《无主题》","date":"2015-04-03T23:04:29.000Z","_content":"\n\n## 2015.04.03\n\n#### style样式在Android中的体现 - 王胜\n* Web开发中，HTML承担了组建的角色，CSS承担了润色的角色，极大提高了Web开发样式和组建的解耦性\n* Android设计之初，借鉴了Web开发的思想，布局中引入了style样式\n* res/values/styles.xml中可以定义组建的样式，然后再布局文件xxxx_layout.xml中可以直接引用。这样样式调整时，只需修改style样式即可。\n\n#### 基于 Github 的 单代码库(非 fork) 开发流程 - 曾铭\n- issues + tag 管理需求+bugs\n- 非 fork 的 Create Pull Requests 方式\n- 在 Pull Requests 中进行 Code Review\n- Commit 内容如何与 issues, pulls 关联\n\n#### storyboard中cell宽度问题 - 张超耀\n- 在Xcode6，iOS8之后，storyboard中，若在width（any）和height（any）情况下自动布局中tableview的cell初始的宽度是600，只有在tableview实例化cell的时候才会自动计算出cell的宽度。在这种情况下，若事先需要cell的宽度（例如，需要根据内容来判断cell高度等），需要结合`-(void)viewWillLayoutSubviews`来做相应的处理。\n\n","source":"_posts/2015.04.03 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-04-03 23:04:29\ntags:\n---\n\n\n## 2015.04.03\n\n#### style样式在Android中的体现 - 王胜\n* Web开发中，HTML承担了组建的角色，CSS承担了润色的角色，极大提高了Web开发样式和组建的解耦性\n* Android设计之初，借鉴了Web开发的思想，布局中引入了style样式\n* res/values/styles.xml中可以定义组建的样式，然后再布局文件xxxx_layout.xml中可以直接引用。这样样式调整时，只需修改style样式即可。\n\n#### 基于 Github 的 单代码库(非 fork) 开发流程 - 曾铭\n- issues + tag 管理需求+bugs\n- 非 fork 的 Create Pull Requests 方式\n- 在 Pull Requests 中进行 Code Review\n- Commit 内容如何与 issues, pulls 关联\n\n#### storyboard中cell宽度问题 - 张超耀\n- 在Xcode6，iOS8之后，storyboard中，若在width（any）和height（any）情况下自动布局中tableview的cell初始的宽度是600，只有在tableview实例化cell的时候才会自动计算出cell的宽度。在这种情况下，若事先需要cell的宽度（例如，需要根据内容来判断cell高度等），需要结合`-(void)viewWillLayoutSubviews`来做相应的处理。\n\n","slug":"2015.04.03 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dyp000stfptly2rmqex"},{"title":"《无主题》","date":"2015-03-27T23:04:29.000Z","_content":"\n## 2015.03.27\n\n#### APP分享 - 张超耀\n- [网易云音乐](http://music.163.com/#/download)\n\t- 播放界面的毛玻璃效果值得借鉴。\n\t- 网易云音乐是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。\n\t\n- [一问](http://yiwen.fm)\n \t- 「一问」会坚持每天介绍一家创业公司，包括该创业公司的一开始的想法和思路，想创业的童靴可以参考下。\n \t\n- [forest](https://itunes.apple.com/tw/app/forest-bao-chi-zhuan-zhu-ju/id866450515?l=zh&mt=8)\n\t- 「Forest」是一个帮助您专心于生活中每个重要时刻的APP。\n\t- Forest能帮助您远离智慧型手机的诱惑。每当您想要专注时，种下种籽吧！在接下来的30分钟内，它将成长成为一棵大树。\n\t\n- [500px](https://500px.com) \n\t- 「500px」是一个致力于来自世界各地的摄影师的摄影分享、发现、售卖的专业平台。\n\t-  APP的loading不错，小创意值得学习。\n\n- [any.do](http://www.any.do)\n\t- 无论从UI设计、易用性、实用性来讲，Any.Do 都在上流水准！Any.Do凭借简洁大方的界面设计和便捷直观的操作收获了大量用户，并通过云技术将日程安排等数据自动同步，帮助用户随时随地更系统更方便地管理自己的日程安排，让它来管理的你的日常生活再好不过了。\n\n#### App 分享 - 王胜\n\n- [金山词霸](http://www.iciba.com)\n\t- 本地、在线翻译功能\n\t- 每日一句很有文艺范\n\t- 最大亮点拍照翻译功能，支持自动取词、点击取词、长句拍译。以后再看到不会输入的日韩文字，一拍照，轻松搞定\n- [手机百度](http://xbox.m.baidu.com/wuxian)\n\t- 搜索功能\n\t- 最大亮点拍照搜索，以后参观植物园、动物园再也不用担心不知道这个是什么花，那个是什么动物了\n\n#### App 分享 - 郁兵生\n\n#### App 分享 - 曾铭\n\n- [Slack](https://slack.com/)\n\t- 坐上火箭的公司[36Kr](http://www.36kr.com/p/219324.html)\n\t- 交流：（人员:channels、信息流 integration）\n\t- 重视用户反馈\n- [Tweetbot](http://tapbots.com/tweetbot/)\n\t- 无数神细节\n\t- 发布@#以及草稿\n\t- 一个@的产品设计\n- [GBA4iOS](http://www.gba4iosapp.com/)\n\t- 一个模拟器该有的样子\n\t- 开源\n- [世界迷雾](http://zh-hans.fogofworld.com/)\n\t- 一个应用（游戏）的世界观\n\t- 使用一生的应用\n- [Seven](http://www.perigee.se/seven.php)\n\t- 7分钟，坚持七个月 5%%\n\t- 成就+❤，进度+回顾\n\t- 收费\n\n#### App 分享 - 顾鹏凌\n\n","source":"_posts/2015.03.27 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-03-27 23:04:29\ntags:\n---\n\n## 2015.03.27\n\n#### APP分享 - 张超耀\n- [网易云音乐](http://music.163.com/#/download)\n\t- 播放界面的毛玻璃效果值得借鉴。\n\t- 网易云音乐是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。\n\t\n- [一问](http://yiwen.fm)\n \t- 「一问」会坚持每天介绍一家创业公司，包括该创业公司的一开始的想法和思路，想创业的童靴可以参考下。\n \t\n- [forest](https://itunes.apple.com/tw/app/forest-bao-chi-zhuan-zhu-ju/id866450515?l=zh&mt=8)\n\t- 「Forest」是一个帮助您专心于生活中每个重要时刻的APP。\n\t- Forest能帮助您远离智慧型手机的诱惑。每当您想要专注时，种下种籽吧！在接下来的30分钟内，它将成长成为一棵大树。\n\t\n- [500px](https://500px.com) \n\t- 「500px」是一个致力于来自世界各地的摄影师的摄影分享、发现、售卖的专业平台。\n\t-  APP的loading不错，小创意值得学习。\n\n- [any.do](http://www.any.do)\n\t- 无论从UI设计、易用性、实用性来讲，Any.Do 都在上流水准！Any.Do凭借简洁大方的界面设计和便捷直观的操作收获了大量用户，并通过云技术将日程安排等数据自动同步，帮助用户随时随地更系统更方便地管理自己的日程安排，让它来管理的你的日常生活再好不过了。\n\n#### App 分享 - 王胜\n\n- [金山词霸](http://www.iciba.com)\n\t- 本地、在线翻译功能\n\t- 每日一句很有文艺范\n\t- 最大亮点拍照翻译功能，支持自动取词、点击取词、长句拍译。以后再看到不会输入的日韩文字，一拍照，轻松搞定\n- [手机百度](http://xbox.m.baidu.com/wuxian)\n\t- 搜索功能\n\t- 最大亮点拍照搜索，以后参观植物园、动物园再也不用担心不知道这个是什么花，那个是什么动物了\n\n#### App 分享 - 郁兵生\n\n#### App 分享 - 曾铭\n\n- [Slack](https://slack.com/)\n\t- 坐上火箭的公司[36Kr](http://www.36kr.com/p/219324.html)\n\t- 交流：（人员:channels、信息流 integration）\n\t- 重视用户反馈\n- [Tweetbot](http://tapbots.com/tweetbot/)\n\t- 无数神细节\n\t- 发布@#以及草稿\n\t- 一个@的产品设计\n- [GBA4iOS](http://www.gba4iosapp.com/)\n\t- 一个模拟器该有的样子\n\t- 开源\n- [世界迷雾](http://zh-hans.fogofworld.com/)\n\t- 一个应用（游戏）的世界观\n\t- 使用一生的应用\n- [Seven](http://www.perigee.se/seven.php)\n\t- 7分钟，坚持七个月 5%%\n\t- 成就+❤，进度+回顾\n\t- 收费\n\n#### App 分享 - 顾鹏凌\n\n","slug":"2015.03.27 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dys000ttfptamgkmnoe"},{"title":"《无主题》","date":"2015-03-20T23:04:29.000Z","_content":"\n\n## 2015.03.20\n\n#### storyboard使用的总结和心得 - 张超耀\n* storyboard以直观的界面流程图展现软件的业务流程，使开发和维护思路更加清晰，一目了然。\n* UI控件在storyboard中添加约束条件后，可在代码中对其约束条件的constant属性进行修改\n* UI控件的一些特殊属性（例如cornerRadius、offset等）在storyboard中可自实现（Key Path - Type - Value）\n* 结合代码实现navigation Bar的现实与隐藏\n* Storyboard提供的 Static cell特性只适合于UITableViewController的子类。我很多时候的用法是一个TableView嵌套在另一个UIView中，static cell就不能用了。\n\n#### JSON2Model 转换技术分享 - 曾铭\n* NSDictionary 转换至对应对象所面临的问题：代码繁复、安全难以保证（导致 crash）；\n* [YIModel](https://github.com/mithvv/YIModel) 通过 `runtime` 如何设计解决这些问题，并支持 `NSCoding`、`NSCopy`\n* 更好的实现：[JSONModel](https://github.com/icanzilb/JSONModel) \n\n","source":"_posts/2015.03.20 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-03-20 23:04:29\ntags:\n---\n\n\n## 2015.03.20\n\n#### storyboard使用的总结和心得 - 张超耀\n* storyboard以直观的界面流程图展现软件的业务流程，使开发和维护思路更加清晰，一目了然。\n* UI控件在storyboard中添加约束条件后，可在代码中对其约束条件的constant属性进行修改\n* UI控件的一些特殊属性（例如cornerRadius、offset等）在storyboard中可自实现（Key Path - Type - Value）\n* 结合代码实现navigation Bar的现实与隐藏\n* Storyboard提供的 Static cell特性只适合于UITableViewController的子类。我很多时候的用法是一个TableView嵌套在另一个UIView中，static cell就不能用了。\n\n#### JSON2Model 转换技术分享 - 曾铭\n* NSDictionary 转换至对应对象所面临的问题：代码繁复、安全难以保证（导致 crash）；\n* [YIModel](https://github.com/mithvv/YIModel) 通过 `runtime` 如何设计解决这些问题，并支持 `NSCoding`、`NSCopy`\n* 更好的实现：[JSONModel](https://github.com/icanzilb/JSONModel) \n\n","slug":"2015.03.20 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dz9000utfptq9q1d9oc"},{"title":"《无主题》","date":"2015-03-13T23:04:29.000Z","_content":"\n## 2015.03.13\n\n#### 开发工具分享（1） - 曾铭\n- Chrome 开发插件：原生开发工具（定位内容，网络请求），[Postman](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en)（API 调试），[JsonView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=en)（JSON API format）\n- [Alfred](http://www.alfredapp.com/)：快速启动，多重剪贴板，workflows（无比强大，自定工作流。快速切换 dns，搜豆瓣，关联 Dash……）\n- [Dash](http://kapeli.com/dash)：文档速查，支持所有文档，速查 google，stackoverflow\n- [Pushbullet](https://www.pushbullet.com/)：全平台，快速推送文字，图片，与 Mac 共享剪贴板\n\n总结：\n- 只用最好的\n- 学习工具要思考工具所解决的问题（有没有更好的方法），技术的实现思路（有没有更多的用法）。\n\n#### 开发工具分享 & Xcode6疑问 & button图片文字共存 技术分享 - 张超耀\n##### 开发工具分享\n\n- Sip取色器：在iOS开发过程中，经常遇到颜色获取问题，用Sip可以吸取颜色并转换成相应的代码，只需要复制在相应的代码块即可。\n- Json解析：Json是一款本地Json串的解析，可以对Json串进行编辑，可以检查URL是否有效。\n\n##### Xcode6中怎么像Xcode5那样创建一个空的项目\n- 删除Main.storyboard 同时 Main Interface指向空\n\t- （原来这样就可以（感谢曾铭的分享））一直很复杂的走几步，今天才发现是弯路\n\n##### UIButton显示文字和图片\n- UIButton上的图片和文字位置调整： \n\t- 图片位置属性设置：imageEdgeInsets \n\t- 文字位置属性设置：contentEdgeInsets　\n\n\n####  iOS 开发分享功能 - 朱崇铭\n##### 友盟分享\n- 友盟社会化组件，可以让移动应用快速具备社会化分享、登录、评论、喜欢等功能。\n- 首先获取友盟Appkey，并且去需要分享的社交圈获得标识。然后需要集成友盟SDK嵌入到代码。\n\n##### Share分享。\n- ShareSDK是中国最大的APP内分享服务提供商ShareSDK社会化分享。\n- 全面支持微信，微博，QQ空间，来往，易信，Facebook等国内外40个平台。比友盟体验好一些（UI，设计，功能，自定义）。\n- 在官方下载ShareSDK并导入到工程。添加一些依赖框架。并配置好所有交易平台的 KEY。URL Scheme。\n\n##### 为iOS app添加AirDrop文件分享功能\n- AirDrop是iOS7 引入的一项新功能，AirDrop可以在不同用户的iOS设备之间进行照片和文档的分享。\n- 苹果在iOS 7 SDK中集成了UIActivityViewController类，可以让你很简单地就能把AirDrop功能整合进app中。\n- 你就能通过AirDrop选项启用activity view。当检测到周围的设备时，activity controller会自动展示在设备上。　\n\n","source":"_posts/2015.03.13 - <无主题>.md","raw":"title: 《无主题》\ndate: 2015-03-13 23:04:29\ntags:\n---\n\n## 2015.03.13\n\n#### 开发工具分享（1） - 曾铭\n- Chrome 开发插件：原生开发工具（定位内容，网络请求），[Postman](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en)（API 调试），[JsonView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=en)（JSON API format）\n- [Alfred](http://www.alfredapp.com/)：快速启动，多重剪贴板，workflows（无比强大，自定工作流。快速切换 dns，搜豆瓣，关联 Dash……）\n- [Dash](http://kapeli.com/dash)：文档速查，支持所有文档，速查 google，stackoverflow\n- [Pushbullet](https://www.pushbullet.com/)：全平台，快速推送文字，图片，与 Mac 共享剪贴板\n\n总结：\n- 只用最好的\n- 学习工具要思考工具所解决的问题（有没有更好的方法），技术的实现思路（有没有更多的用法）。\n\n#### 开发工具分享 & Xcode6疑问 & button图片文字共存 技术分享 - 张超耀\n##### 开发工具分享\n\n- Sip取色器：在iOS开发过程中，经常遇到颜色获取问题，用Sip可以吸取颜色并转换成相应的代码，只需要复制在相应的代码块即可。\n- Json解析：Json是一款本地Json串的解析，可以对Json串进行编辑，可以检查URL是否有效。\n\n##### Xcode6中怎么像Xcode5那样创建一个空的项目\n- 删除Main.storyboard 同时 Main Interface指向空\n\t- （原来这样就可以（感谢曾铭的分享））一直很复杂的走几步，今天才发现是弯路\n\n##### UIButton显示文字和图片\n- UIButton上的图片和文字位置调整： \n\t- 图片位置属性设置：imageEdgeInsets \n\t- 文字位置属性设置：contentEdgeInsets　\n\n\n####  iOS 开发分享功能 - 朱崇铭\n##### 友盟分享\n- 友盟社会化组件，可以让移动应用快速具备社会化分享、登录、评论、喜欢等功能。\n- 首先获取友盟Appkey，并且去需要分享的社交圈获得标识。然后需要集成友盟SDK嵌入到代码。\n\n##### Share分享。\n- ShareSDK是中国最大的APP内分享服务提供商ShareSDK社会化分享。\n- 全面支持微信，微博，QQ空间，来往，易信，Facebook等国内外40个平台。比友盟体验好一些（UI，设计，功能，自定义）。\n- 在官方下载ShareSDK并导入到工程。添加一些依赖框架。并配置好所有交易平台的 KEY。URL Scheme。\n\n##### 为iOS app添加AirDrop文件分享功能\n- AirDrop是iOS7 引入的一项新功能，AirDrop可以在不同用户的iOS设备之间进行照片和文档的分享。\n- 苹果在iOS 7 SDK中集成了UIActivityViewController类，可以让你很简单地就能把AirDrop功能整合进app中。\n- 你就能通过AirDrop选项启用activity view。当检测到周围的设备时，activity controller会自动展示在设备上。　\n\n","slug":"2015.03.13 - <无主题>","published":1,"updated":"2015-07-10T07:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibxu4dzb000vtfpt6yy33ju3"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cibxu4dy20003tfptoxus6emq","tag_id":"cibxu4dy30004tfptu4ny9bsi","_id":"cibxu4dy50006tfpt1le6aoai"},{"post_id":"cibxu4dy20003tfptoxus6emq","tag_id":"cibxu4dy50005tfptnufzjbro","_id":"cibxu4dy50007tfpt487u6u2g"},{"post_id":"cibxu4dy70008tfptfrlckqx3","tag_id":"cibxu4dy80009tfptarj6zqtd","_id":"cibxu4dy8000btfpts8ujzwsx"},{"post_id":"cibxu4dy70008tfptfrlckqx3","tag_id":"cibxu4dy8000atfptfhmsjv70","_id":"cibxu4dy8000ctfpt1rvivnf2"},{"post_id":"cibxu4dya000etfptyxl3hpc9","tag_id":"cibxu4dyb000ftfpt7ekjejd3","_id":"cibxu4dyb000htfptm2l3at1p"},{"post_id":"cibxu4dya000etfptyxl3hpc9","tag_id":"cibxu4dyb000gtfpt4p9ykdh5","_id":"cibxu4dyc000itfpth0i1tdmb"},{"post_id":"cibxu4dyc000jtfptwrn8mlv4","tag_id":"cibxu4dyd000ktfpt8za13wrh","_id":"cibxu4dyd000ltfptqk3ylt91"}],"Tag":[{"name":"线程","_id":"cibxu4dy30004tfptu4ny9bsi"},{"name":"同步异步","_id":"cibxu4dy50005tfptnufzjbro"},{"name":"开发效率","_id":"cibxu4dy80009tfptarj6zqtd"},{"name":"效率","_id":"cibxu4dy8000atfptfhmsjv70"},{"name":"博客","_id":"cibxu4dyb000ftfpt7ekjejd3"},{"name":"网站","_id":"cibxu4dyb000gtfpt4p9ykdh5"},{"name":"游戏","_id":"cibxu4dyd000ktfpt8za13wrh"}]}}