title: 周精益分享 - 后端开发
date: 2015-11-25  10:30:00
tags:
---

##  Swift学习之二 - 张超耀     

###  深度理解"?" && "!"

 ``` Optional其实是个enum，里面有None和Some两种类型。 nil就是Optional.None, 非nil就是Optional.Some, 然后会通过Some(T)包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因。声明为Optional只需要在类型后面紧跟一个"?"即可
 ```
```
var strValue: String?  //?相当于下面这种写法的语法糖
var strValue1: Optional<Int>
```

 一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断：

```
if (strValue != nil) {
    //do sth with strValue
}
```

怎么使用Optional值呢？
在使用Optional值的时候只前面需要加上一个"?"，就是这么简单。 
-  这个"？"什么意思？：
	1、  询问是否响应后面这个方法，如果是nil值，也就是Optional.None，就不响应后面的方法，直接跳过，
	2、 如果有值，就是Optional.Some，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如
	
```
let hashValue = strValue?.hashValue

```

- strValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的值

- 到这里我们看到了?的两种使用场景:
            1.声明Optional值变量
            2.用在对Optional值操作中，用来判断是否能响应后面的操作
- 对于Optional值，不能直接进行操作，否则会报错
```
let hashValue1 = strValue!.hashValue
```

 上面错误提示需要拆包(unwrap)后才能得到值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是Optional Binding
```
if let str = strValue {
    let hashValue = str.hashValue
}
```
还有一种是在具体的操作前添加"!"符号。
```
let hashValue2 = strValue!.hashValue
```
 这里的"!"表示**我确定肯定这里的的strValue一定是非nil的，随便用吧，木事de** 就像下面：
```
if (strValue != nil) {
    let hashValue = strValue!.hashValue
}
```
```
{}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。
当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。
```

*** 51offer例子解释『隐式拆包的Optional』***
```
这种是特殊的Optional，称为Implicitly Unwrapped Optionals, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个!进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。
```

- "!"也有两种使用场景
        1、强制对Optional值进行拆包(unwrap)
        2、声明Implicitly Unwrapped Optionals值，一般用于类中的属性



### swift 断言
```
断言（Assertions）
Optionals可以让我们检测值是否存在。在某些情况下，如果某个值不存在或者没有提供特定的满足条件，代码不应该继续往下执行。
在这些情况下，可以使用触发断言来终止执行并提供调试。
断言是在运行时检测条件是否为true,如果为true,就继续往下执行，否则就在这里中断。
```
```
var jobs = "我是一个好人"
assert(jobs == "我是一个好人", "我是一个好人")
assert(jobs == "我是一个坏人", "我是一个坏人么？")
```
```
什么时候使用断言呢？
包含下面的情况时使用断言：
        1、整型下标索引作为值传给自定义索引实现的参数时，但下标索引值不能太低也不能太高时，使用断言
      **2、传值给函数但如果这个传过来的值无效时，函数就不能完成功能时，使用断言。
        3、Optional值当前为nil，但是后面的代码成功执行的条件是要求这个值不能为nil，使用断言
```



## InputView与键盘响应优化方案 - 杨志平


## 写负责任的代码之异常处理 - 曾铭

> 千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。

- 重视代码（及业务）逻辑的异常情况，将其视为『正常流程』的一部分。


- 重视函数的抛出异常，将其视为返回值之一（union类型）。

### 政策之后的对策

``` java
String foo() throws MyException {
}
```

- catch 全部异常


- try 全部代码

``` java
try {
  ...
  ...
  ... foo() ...
  ...
  ...
} catch (Exception e) {}
```

#### 我们 API 为什么难调试

- Service 层未声明抛出异常，也会抛出异常
- 抛出的异常 API 层记入日志，向上抛时却丢弃了异常信息
- API 层方法代码全部 try，很难定位到是哪一行出问题

### 推荐的对策

- 只 catch 指定的 exception
- try 进可能的小

``` java
try {
  foo();
} catch (MyException e) {
  Log.warning(e);
}
```

- 源头思考全部可能性，内部的问题不抛给别人
- 不要试图忽略（隐藏）错误，每次出错都是优化代码（反思自己局限）的好机会。否则，你终将付出代价。
